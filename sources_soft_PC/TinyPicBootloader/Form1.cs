/* ---------------------------------------------------------------------------------------
 * Tiny Avr/Pic Bootloader+
 * 
 * This code was written by Edorul (edorul@free.fr)
 *                      and Dan (http://www3.hp-ez.com/hp/bequest333)
 * It can be downloaded at:
 *      http://sourceforge.net/projects/tinypicbootload/
 * 
 * This software is under "Creative Commons Attribution Non-Commercial License":
 *  - you can use it at home for free
 *  - you can use it at work for free
 *  - you can share it for free, but this licence must remain the same
 *  - you can modify it as you want, but this licence must remain the same
 *  - you CAN'T sell it, even if you have modified it
 * 
 * The idea and first realisation of "Tiny PIC Bootloader" is the work of Claudiu Chiculita.
 * His web site is here:
 *      http://www.etc.ugal.ro/cchiculita/software/picbootloader.htm
 * It worth the look!
 * Thank a lot for this great work!!!
 * 
 * This code is based on "Tiny Pic Bootloader for GNU/Linux" written in python by Ferezvi.  
 * ---------------------------------------------------------------------------------------
 */

/* version legends:
 *  o to do
 *  ~ to test
 *  x working
 * 
 * v0.1 to V0.2:
 *  x some tests to detect a PIC device on a serial port
 *  
 * v0.3 (december 2012):
 *  x PIC16F8xx family
 *  x PIC18F family
 *  
 * v0.4 (december 2012):
 *  x PIC32 family (with special ".ld" for boot programs of Microchip HID Bootloader) (firmware must be = v0.4)
 *  x modify "checkHex" for PIC32 hex files
 *  x modify "transfertHexToArray" to be more flexible
 *  x modify "transfertHexToArray" for PIC32 hex file
 *  
 * v0.5 (january 2013):
 *  x modify "listHexFiles" to avoid many times the same file in list
 *  x modify "listHexFiles" to have the last opened file in first place
 *  x modify "listHexFiles" to have the last used file in first place (validated when [Write Flash] is pressed)
 *  x command line use (ex: tinybootloader "C:\toto.hex")
 *  x option to force the use of an other "piccodes.ini" (browse + checkbox "force" in debug tab)
 *  x the application can be called from anywhere, it will always found "config.ini" and "piccodes.ini"
 *  x use progress bar when erasing PIC32 flash program memory (firmware must be >= v0.5)
 *  
 * v0.6 (january 2013):
 *  x PIC32 family (with normal ".ld" OR with special ".ld" for boot programs of Microchip HID Bootloader) 
 *    (firmware must be >= v0.6)
 *  ~ warning if size of hex to program can overwrite bootloader program (i.e. > (maxMemPos - bootloader size))
 *  x bug fix: can transfer more than 64KB 
 *  x changed in "piccodesIniFile" and "configIniFile" path initialisation '\' to '/' for  
 *    linux-mono portage compatibility
 *    
 * v0.6.1 (febuary 2013):
 *  x bug fix: works even if the ".hex" file is in upper or lower case.
 *  x jump to bootloader modification for ".hex" files generated by mikroC32
 *    
 * v0.6.2 (april 2013):
 *  x added some comments in code
 *  ~ some code simplifications for PIC16Fxxx family in "hexToArray" function 
 *  x works even if the letter for PIC family in "piccodes.ini" is in upper or lower case
 *  x every mumeric value in "piccodes.ini" can be in hexa (starting with '$') or in decimal (without '$')
 *  x there is two new properties in "piccodes.ini": 'bootloader size' and 'transfert block size'.
 *    You SHOULD live then as 'default', but if you want to tweak the bootloader you can change them
 *    accordingly to your needs, at your own risks (you can erase the bootloader firmware in the device).
 *  
 * v0.6.2.1 (april 2013):
 *  x bug fix: code simplifications for PIC16Fxxx family in "hexToArray" function, was a very bad idea! 
 *    Bootloader can't work anymore with this family! Use this new version if you use PIC16 devices!!!
 *  
 * v0.6.3 (april 2013):
 *  x modifications in "configureTransfert" function in 'B' family: 
 *    assembly code changes for "goto bootloader_address" and memory page selection. 
 *    Now it can handle different bootloader sizes (not only 100 words), and any max flash memory.
 *    
 * v0.6.4 (may 2013):
 *  x command line: added COMnum and baudrate (tinypicbootloader+.exe "c:\folder 1\folder etc\file name.hex" [COMx [BaudRate]])
 *    If 'COMx' or 'BaudRate' aren't passed in arguments, the previuos option used in the GUI (stored in the 
 *    "config.ini" file) will be used.
 *    Examples: tinypicbootloader+.exe "c:\test file.hex" COM8 9600
 *              tinypicbootloader+.exe "c:\test file.hex" com8
 *              tinypicbootloader+.exe "c:\test file.hex"
 *  x RS232 power supply (based on Dan's idea and schematic): DTR and RTS can be used to power the PIC device 
 *    directly with RS232 port (only during programming!!!). These options are in the debug tab.
 *      Schematic for use this capacity is given in "Tiny PIC Bootloader +" web site:
 *         http://tinypicbootload.sourceforge.net/hardware_connection.html
 *      It's based on Dan's idea and schematic.
 *    Note: As the PIC device is only powered during programming, then it works as automatic reset.
 *  x modifications in "config.ini" to keep trace of DTR/RTS powering.
 *    !!! previous version of "config.ini" file is no more compatible with "Tiny PIC Bootloader+ v0.6.4" 
 *    (you just have to erase it, it will be created automaticaly the next time you'll use "Tiny PIC Bootloader+")!!!
 *  x modification for PIC16F88 in "piccodes.ini":
 *     $33, B, 16F 88, $2000, $100, default, 64,
 *    
 * v0.6.5 (may 2013):
 *  x modifications in "transfertHexToArray" to handle some PIC12 and PIC16 with Configuration words at 0x8007
 *    and not at 0x2007.
 *  x added EEPROM write for normal (e.g. PIC16F886, etc) and enhanced (e.g. PIC12F1840, PIC16F1823, etc) midrange 
 *    families.
 *  x added EEPROM write for PIC18 family (even if EEPROM > 256 bytes).
 *    !!! previous firmwares of PIC18 devices aren't compatible with "Tiny PIC Bootloader+" EEPROM write
 *    (you must use PIC18's firmwares from the archive of "Tiny Pic Bootloader+" >= v0.6.5) !!!
 *	  If you don't need EEPROM write, then old PIC18 firmwares can still be used with "Tiny Pic Bootloader+" >= v0.6.5
 *  x added the possibility to use a virtual PIC device in debug tab (only usefull for PC software developers).
 *  x modifications in "config.ini" to keep trace of the virtual PIC.
 *    !!! previous version of "config.ini" file is no more compatible with "Tiny PIC Bootloader+ v0.6.5" 
 *    (you just have to erase it, it will be created automaticaly the next time you'll use "Tiny PIC Bootloader+")!!!
 *  x added "Abort" button to interrupt the current operation (i.e. auto conf com, write or check pic).
 *  x modification in "auto COM conf" algorithm: at first try the latest COM and Baudrate configuration used.
 *  x added "auto" option in command line, in order to have automatic COM configuration even with command line: 
 *       tinypicbootloader+.exe "c:\folder 1\folder etc\file name.hex" [COMx [BaudRate|auto])
 *    example: tinypicbootloader+.exe "c:\test file.hex" auto
 *    
 * v0.7.0 (july 2013):
 *  x Atmel AVR ATtiny devices supported (by Dan)
 *  
 * v0.7.0.2 (july 2013):
 *  x bug fix: for PIC18 family, if there are "User ID" bytes in hex file they will be discarded (not written) 
 *    instead of displaying "Error: hex file too large, writing bootloader firmware!!!".
 *  x bug fix: when in "Debug" tab "Show answer during [Check Device]" is checked, now display answer even when 
 *    only 1 byte is received. 
 *  x now [Check Device] is not stopped by a not opened COM (could be usefull if COM is only available during the
 *    test but not at its start) 
 *    
 * v0.7.1 (july 2013)
 *  x Drag & Drop allowed. If in the objects put on the windows form they are ".hex" or ".eep" (EEPROM for AVR) files then:
 *              - add the first one to "listHexFiles" list view and select it 
 *              - write it to the device
 *  x added in debug tab, displaying of raw data during communication with a device.
 *  x can select if flash program memory must be programmed or not in the device (allow to write only EEPROM)
 *  x modifications in "config.ini" to keep trace if flash program memory must be written or not.
 *    !!! previous version of "config.ini" file is no more compatible with "Tiny AVR/PIC Bootloader+ v0.7.1" 
 *    (you just have to erase it, it will be created automaticaly the next time you'll use "Tiny PIC Bootloader+")!!!
 *  x can open EEP (EEPROM file for AVR) or HEX files. If EEP file is choosen, the program will try to search the 
 *    corresponding HEX file.
 *  x bug fix: .EEP file now well displayed when "show hex file during transfert" is checked
 *  
 * v0.8.0 (july 2013)
 *  x Atmel AVR ATmega devices supported (by Dan)
 *  x family for AVR ATtiny changed from "#A" to "1"
 *  x changed device answer type. Instead of "0xID_device 0x4B" it's now "0xID_device 0xASCII(upper_case_Family_code)". 
 *    By this way we could have 256 different devices in every family, and not 256 for the whole families.
 *    Old firmwares are still compatibles with this new device answer type.
 *  x added "family" for virtual device in the debug tab.
 *  x modifications in "config.ini" to keep trace of modification for virtual device in debug tab.
 *    !!! previous version of "config.ini" file is no more compatible with "Tiny AVR/PIC Bootloader+ v0.7.1" 
 *    (you just have to erase it, it will be created automaticaly the next time you'll use "Tiny PIC Bootloader+")!!!
 *  x added Help by clicking on [?(F1)] button, or by pressing "F1" key, then click on a control to display its
 *    function.
 *  x added "Online Support" link to the forum
 *  
 * v0.8.1 (august 2013)
 *  x added Config Bytes write for PIC18 family (only PIC18F2455 firmware can handle this option)
 *  x added the possibility to manually enter weird "baud rates" (like 111456) in order to adapt the baud rate to 
 *    the new PIC speed (if modified by the Config Bytes Write)
 *  x in debug tab a "special baud rates" group was added to calculate weird baud rates as a fonction of old 
 *    baudrate, old and new PIC frequencies. This calculated baudrate is automatically added to the "Baud Rate" combobox.
 *  x 'added baudrates to the "Baud Rate" combobox' are saved in "config.ini"
 *  x progress bar display modification: restart from 0 at each new process (e.g. EEPROM write, Boot Flash write,
 *    Program Flash write, etc...)
 *  x bug fix: only write the EEPROM bytes which are present in the "hex" file. Now, leave other data in EEPROM untouched
 *  x bug fix: write EEPROM byte even if it equals 0xFF
 *  x added "Erase EEPROM" option
 *  x changed "config.ini" loading process in order to keep new versions of "TinyBootloader+" compatibles with 
 *    older "config.ini". 
 *  x bug fix: for PIC16 normal and enhanced families, if there are "User ID" bytes in hex file they will be discarded 
 *    (not written) instead of displaying "Error: hex file too large, writing bootloader firmware!!!".
 *  x bug fix: some PIC16 hex files aren't detected as PIC18 ones anymore.
 *  
 * v0.8.2 (october 2013)
 *  x new "J" family for PIC18FxxJxx devices, from Dan
 *  x bug fix: when "erase EEPROM" checked and "EEPROM" unchecked, no longer erase the begining of the flash program
 *    instead of EEPROM memory.
 *  x bug fix: if "EEPROM" unchecked and if they are EEPROM data in ".hex" file, they are no longer written
 * 
 * v0.8.3 (november 2013)
 *  x re-enable "RTS False" time in the debug tab. From Sunish's bug report:
 *    "RTS reset false (ms) option should be enabled in the form. If the software starts sending 0xC1 PIC will not 
 *     respond correctly if there is no delay between rts = true and rts = false. 
 *     With 12f1840 I found 500 and 100 to be ideal."
 *  x changed some typo mistakes (thanks to Sunish).
 *  x bug fix: program hang no more when programming full EEPROM memory on PIC16 family (Dan).
 * 
 * v0.8.3.1 (febury 2014)
 *  x bug fix: handle bug from Great Cow Basic generation ".hex" file -> number of configuration bytes are in excess
 *  x bug fix: configuration bytes write for PIC32 is disabled, because it doesn't work fine for the moment (thanks to Davide Spazian)
 *  x bug fix: in some conditions, 0x00 can be stuck in serial buffer. Now erase serial buffer before listening 
 *    microcontroller (bug report: donvukovic / bug fix: Dan)
 *    
 * v0.9.0 (july 2014)
 *  x new "D" family for dsPIC30F, PIC24F, PIC24FV, PIC24HJ, PIC24E(Partial), dsPIC33F(Partial), dsPIC33E(Partial) devices, from Dan (Thanks a lot Dan!)
 *  x new "E" family for PIC24FJ, PIC24E(Partial), dsPIC33F(Partial), dsPIC33E(Partial) devices, from Dan
 *  Remark : Distinction of the E-type and D-type = Relationship with the E-type and D-type is similar to the relationship of PIC18J and PIC18. "Flash Config Words" does not exist in the D-type.
 *           look at http://sourceforge.net/p/tinypicbootload/discussion/general/thread/dd60ff68/
 *  x new "3" family for NXP ARM Cortex-M0/0+ LPC devices, from Dan
 *  x in "checkHex" function, added some warnings during check hex file (and then return true):
 *    - for PIC24, dsPIC30 and dsPIC33: not verified
 *    - for NPX: not verified
 *    - for enhanced PIC16: can't tell if it's PIC18 or enhanced PIC16*
 *  x bug fix: if "config.ini" is a read-only file or is in a read-only folder there is no more error, instead 
 *    a message is displayed.
 *  
 * v0.9.1 (december 2014):
 *  test purpose only for "remote signal software reset" option asked by Mark
 *  
 * v0.10.0 (febuary 2015):
 *  x bug fix by Danny ON4CLU: if there is no COM port connected to the computer, there is no more error at startup.
 *  x bug fix: if "Force use of "piccodes.ini" file" is checked or unchecked in the "configuration" tab, then there is 
 *    no more need to restart the program to take it into account.
 *  x bug fix: if "auto" command line parameter is passed with no COM attached to the PC, then there is no more crash.
 *  x new "4" family for TI MPS430 devices, from Dan
 *  x new "5" family for 8051 devices, from Dan
 *  x removed: Help by clicking on [?(F1)] button, or by pressing "F1" key.
 *  x added: Help Messages Tooltips (can be desactivated with the "Show Help Messages" option). 
 *  x added: "configuration" tab
 *  x some elements of the "Debug" tab moved to the new "Configuration" tab.
 *  x added: DTR hadware reset option (utilised by Dan)
 *  x added: picture in "configure" tab to explain RTS true and false times.
 *  x added: link to the online documentation (http://tinypicbootload.sourceforge.net/)
 *  x added: link to the online tested devices pages
 *  x change caption of the "Write Device" button to "Simulate" if "virtual device" is checked in the "debug tab".
 *    This can avoid some unexplicable untransferred programs ;-)
 *  x added: "remote signal software reset" option (asked by Mark): a user selectable string (configured by entering 
 *    the ascii codes separated by spaces in the "Remote Reset Signal" groupbox in the Configure" tab) will be sent, 
 *    so your application (not the bootloader) receives the "remote message" and reboots the device.
 *  x command line: seek the baudrate given in arguments in the "Baud Rate" list box and not only in a predefined list 
 *    (because user can add personal values in the "Baud Rate" list box)
 *  x command line (asked by Anobium): added "exit" option, it close TinyBootloader ONLY in case of a successfull write.
 *  
 * v0.11.0
 *  x added: "firmware" tab for firmware infos (firmware folder, internal/external clock, default Bauds, default RX and TX pins...) 
 *    and for programming PIC firmware (only) with Microchip's programmers (PicKit3, Real Ice, ICD3, PM3 and PKOB–"PICkit on board") 
 *    and IPECMD software (Microchip/MPLABX/v3.30/docs/Readme for IPECMD.htm) directly from TinyMultiBootloader+ interface.
 *  x added: in "firmware" tab, the user is able to select "firmwares" folder (by default it is in the same folder than "TinyMultiBootloader+.exe")
 *  x added: in "firmware" tab, display firmware's device info when the firmware is selected by it's brand, device and then 
 *    firmware's flavour (if more than one)
 *  x added: in "firmware" tab, the user is able to define where is the "ipecmd.exe" file utilized to flash the PIC device
 *  x added: in "firmware" tab, with your PIC programmer you can flash the PIC device with the selected firmware
 *  
 * future:
 *  o help for "write Config", "erase EEPROM", and "special baud rates"
 *  o bug fix: if enhanced PIC16 family hex file has configuration bytes, EEPROM data, or User ID, it is no more
 *    detected as PIC18 family.
 *  o command line: wildcard caracters can be used in filename
 */

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.IO;
using System.IO.Ports; // else can't use "SerialPort.GetPortNames()" even if a serialPort is added to the form
using System.Threading;
using System.Diagnostics;

namespace TinyPicBootloader
{
    public partial class Form1 : Form
    {
        private const int WM_SYSCOMMAND = 0x112;
        private const int SC_CONTEXTHELP = 0xf180;
        [System.Runtime.InteropServices.DllImport("user32.dll")]
        private static extern IntPtr SendMessage(IntPtr hWnd, int msg, IntPtr wp, IntPtr lp);

        // some defines in order to have a code easier to read
        const byte nbInfosPerLine = 7; // for a device in "piccodes.ini"
        const byte firmwaresIniMaxInfoPerline = 8;
        const byte EEP_FILE_NONE = 0;
        const byte EEP_FILE_EXISTS = 11;
        const byte familyPicC_ConfigBytesSize = 14;
        const byte familyPicJ_ConfigBytesSize = 8;
        const byte familyPicD_ConfigBytesSize = 18;
        const byte familyPicE_ConfigBytesSize = 20;
        // device's family bootloader size (in bytes)
        const int familyPicB_DefaultBootloaderSize = 200; // in bytes
        const int familyPicC_DefaultBootloaderSize = 200; // in bytes
        const int familyPicD_DefaultBootloaderSize = 300; // in bytes
        const int familyPicE_DefaultBootloaderSize = 396; // in bytes
        const int familyPicJ_DefaultBootloaderSize = 264; // in bytes
        const int familyPicF_DefaultBootloaderSize = 0x1000; // in bytes
        const int familyAvr1_DefaultBootloaderSize = 168; // in bytes
        const int familyAvr2_DefaultBootloaderSize = 264; // in bytes
        const int familyLpc3_DefaultBootloaderSize = 264; // in bytes
        const int familyMsp4_DefaultBootloaderSize = 136; // in bytes
        const int familyC8051_DefaultBootloaderSize = 196; // in bytes
        // device's family transfert block size (in bytes)
        const int familyPicB_DefaultBlockSize = 8; // in bytes
        const int familyPicC_DefaultBlockSize = 64; // in bytes
        const int familyPicD_DefaultBlockSize = 96; // in bytes
        const int familyPicE_DefaultBlockSize = 192; // in bytes
        const int familyPicJ_DefaultBlockSize = 64; // in bytes
        const int familyPicF_DefaultBlockSize = 128; // in bytes
        const int familyAvr1_DefaultBlockSize = 32; // in bytes
        const int familyAvr2_DefaultBlockSize = 128; // in bytes
        const int familyLpc3_DefaultBlockSize = 64; // in bytes
        const int familyMsp4_DefaultBlockSize = 64; // in bytes
        const int familyC8051_DefaultBlockSize = 32; // in 
        struct picInfos
        {
            public byte idCode;
            public string family;
            public string description;
            public int flashMem; // in bytes
            public int flashMem_Msp; // in bytes
            public int eepromflag; // in bytes		
            public int eepromMem; // in bytes
            public int configSize; // in bytes
            public int minMemPos; // in bytes
            public int maxMemPos; // in bytes (= start of the bootloader memory address)
            public int startPosEEPROM; // in bytes
            public int startPosConfig; // in bytes
            public int blockSize; // in bytes
            public int bootloaderSize; // in bytes
            public int bootloaderSize_Msp; // in bytes
            public int dividerHexToMemory; // for translation of address in hex file to address in PIC memory (only PIC16 is != 1, it equals 2)
            public int totalByteInFile; // in bytes
            public int totalBootByteInFile; // in bytes
            public int totalEepromByteInFile; // in bytes
        }
        picInfos selectedPicInfos = new picInfos();

        byte[] picMem;
        byte[] picEEPROM;
        bool[] picEEPROMchanged; // needed to write EEPROM byte even if it equals 0xFF
        byte[] picConfig;
        byte[] picBootFlash; // only for PIC32
        bool isEEPROM;
        bool isConfig;

        string piccodesIniFile;
        string configIniFile;

        string ipeCmdFile;

        bool aborted = false;

        bool exitSuccessfulWrite = false; // exit on a successful write in command line mode only
        int writeSuccess; // = 1 on successful write, 0 if not

        // structures for stockage of data from "firmwares.ini" files and their display in "Firmwares" tab
        struct Flavour
        {
            public string name;
            public string clock_type;
            public string frequency;
            public string baudrate;
            public string RX_pin;
            public string TX_pin;
            public string firmware_hex_file_name;
        }
        struct Device
        {
            public string name;
            public List<Flavour> flavours;
        }
        struct Brand
        {
            public string name;
            public List<Device> devices;
        }
        List<Brand> allFirmwaresInfos = new List<Brand>();

        public Form1()
        {
            InitializeComponent();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: doBrowse_Click
        // Parameters: windows stuff
        // Return: none
        // Description: if "browse" button is clicked, open a file select dialog with "*.hex" pre-selection
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void doBrowse_Click(object sender, EventArgs e)
        {
            openHexFile.ShowDialog();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: openHexFile_FileOk
        // Parameters: windows stuff
        // Return: none
        // Description: if a "hex" file is correctly selected, then add it to "listHexFiles" list view
        //              and select it for a future use
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void openHexFile_FileOk(object sender, CancelEventArgs e)
        {
            if (listHexFiles.Items.Contains(openHexFile.FileName))
            {
                // file already in list, so remove it before put it at the first place...
                // ... it's easier than just move it to the right place
                listHexFiles.Items.Remove(openHexFile.FileName);
            }
            listHexFiles.Items.Insert(0, openHexFile.FileName); // add file name at the top of the list...
            listHexFiles.SelectedIndex = 0; // and display it in text zone
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: writeFile
        // Parameters: none
        // Return: 0 on write error / 1 on write success
        // Description: this function call successively all other functions to write ".hex" file in the 
        //              PIC program flash memory.
        //              Open selected "hex" file, then check if a PIC with "Tiny PIC BootLoader" firmware
        //              is well connected to PC, eventually check the hex file and finally transfert the
        //              hex file to the PIC's flash memory
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void writeFile()
        {
            bool canTransfert = true;
            bool isHex = false;
            string hexToOpen;
            string eepToOpen;

            writeSuccess = 1;

            if (checkEraseEEPROM.Checked == true)
            {
                DialogResult result = MessageBox.Show("\"Erase EEPROM\" option checked.\r\n\r\nDo you want to continue?",
                    "WARNING:",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Exclamation,
                    MessageBoxDefaultButton.Button2);

                if (result == DialogResult.No)
                    return;
            }

            isEEPROM = false; // for the moment we don't know if there is EEPROM in ".hex"
            isConfig = false; // for the moment we don't know if there are Config Bytes in ".hex"

            // open selected Hex or Eep file if it exists
            if (File.Exists(listHexFiles.Text))
            {
                // Place the writed file to the top of the list
                hexToOpen = listHexFiles.Text;
                listHexFiles.Items.Remove(hexToOpen); // remove it and..
                listHexFiles.Items.Insert(0, hexToOpen); // ... add file name at the top of the list...
                listHexFiles.SelectedIndex = 0; // ... and display it in text zone

                // verify if it's a ".hex" or ".eep" file
                if (hexToOpen.ToLower().EndsWith(".eep"))
                {
                    hexToOpen = listHexFiles.Text.ToLower().Replace(".eep", ".hex");
                }
                // prepare for ".eep" file (determine later if it exists)
                eepToOpen = hexToOpen.ToLower().Replace(".hex", ".eep");
                selectedPicInfos.eepromflag = EEP_FILE_NONE;

                // Write flash sequences
                if (checkPIC(int.Parse(textNbChecks.Text), true)) // Open the serial port and Check if a device is responding
                {
                    // open selected hex file if it exists
                    if (File.Exists(hexToOpen))
                    {
                        isHex = true;
                        // Open the file to read from.
                        textMessages.AppendText("Open HEX file: " + hexToOpen + "\r\n");
                        string[] lines = File.ReadAllLines(hexToOpen);
                        if (checkFile.Checked)
                            canTransfert = checkHex(lines);
                        if (canTransfert)
                            if (transferringFile(lines))
                            {
                                // is there something that have been transfered?
                                if ((checkWriteFlashProg.Checked) ||
                                    ((String.Compare(selectedPicInfos.family, "A") >= 0) && (checkWriteEEPROM.Checked && isEEPROM))
                                    || (checkWriteConfig.Checked && isConfig))
                                    textMessages.AppendText("Transferring HEX successfull :-)\r\n");
                            }
                            else
                            {
                                writeSuccess = 0;
                                textMessages.AppendText("ERROR: problem in writing flash memory!!!\r\n");
                            }
                    }
                    else
                        textMessages.AppendText("WARNING: no \".HEX\" file associated to \".EEP\" file.\r\n");

                    // open selected eep file if it exists and if needed (AVR only)
                    if ((String.Compare(selectedPicInfos.family, "A") < 0) && checkWriteEEPROM.Checked)
                        if (File.Exists(eepToOpen))
                        {
                            // Open the EEPROMfile to read from.
                            textMessages.AppendText("Open EEP file: " + eepToOpen + "\r\n");
                            string[] linesEEPROM = File.ReadAllLines(eepToOpen);
                            selectedPicInfos.eepromflag = EEP_FILE_EXISTS;
                            if (transferringFile(linesEEPROM))
                                textMessages.AppendText("Transferring EEP successfull :-)\r\n");
                            else
                            {
                                writeSuccess = 0;
                                textMessages.AppendText("ERROR: problem in writing AVR EEPROM!!!\r\n");
                            }
                        }

                    // message if nothing was written
                    if (((!checkWriteFlashProg.Checked) || (isHex == false)) && ((!checkWriteEEPROM.Checked) || (isEEPROM == false))
                        && ((!checkWriteConfig.Checked) || (isConfig == false)))
                    {
                        writeSuccess = 0;
                        textMessages.AppendText("WARNING: Nothing was written!\r\n");
                    }
                }
                if (!checkVirtualPIC.Checked)
                    closeSerial(true);
            }
            else
            {
                writeSuccess = 0;
                textMessages.AppendText("ERROR: Can't open file!!!\r\n");
            }

            textMessages.AppendText("\r\n---------------------------------------------------------\r\n\r\n");
            textRawTransfert.AppendText("\r\n\r\n-------------------------\r\n");

            return;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: buttonWrite_Click
        // Parameters: windows stuff
        // Return: none
        // Description: when user clicks on "Write Flash" button it calls "writeFile" function.
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void buttonWrite_Click(object sender, EventArgs e)
        {
            Thread tt = new Thread(new ThreadStart(writeFile));
            aborted = false;
            tt.Start();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: closeSerial
        // Parameters: verbose (if true, then display some messages) 
        // Return: none
        // Description: close serial com previously openned
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void closeSerial(bool verbose)
        {
            serialPort.Close();
            if (verbose)
                textMessages.AppendText("Close " + selectedCOM.Text + " serial port\r\n");
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: openSerial
        // Parameters: verbose (if true, then display some messages)
        // Return: none
        // Description: try to open serial port selected in "selectedCOM" list box with baud rate selected
        //              in "comboBaudSelect" combo box
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void openSerial(bool verbose)
        {
            serialPort.PortName = selectedCOM.Text;
            if (checkUseSpecialBaudRate.Checked == true)
                comboBaudSelect.Text = textBaudFinal.Text;
            // verify if the comboBaudSelect's text is already in the combobox
            // if not, add it in the combobox at the right place
            int index = 0;
            int insertPlace = 0;
            bool needToAdd = true;
            foreach (var baud in comboBaudSelect.Items)
            {
                if (int.Parse(baud.ToString()) > int.Parse(comboBaudSelect.Text))
                    insertPlace = index + 1;
                if (int.Parse(baud.ToString()) == int.Parse(comboBaudSelect.Text))
                    needToAdd = false;
                index++;
            }
            if (needToAdd == true)
                comboBaudSelect.Items.Insert(insertPlace, comboBaudSelect.Text);

            serialPort.BaudRate = int.Parse(comboBaudSelect.Text); //serialPort.BaudRate = int.Parse((string)comboBaudSelect.SelectedItem);
            serialPort.ReadTimeout = int.Parse(textReadTimeOut.Text);
            // Power by RS232  
            serialPort.RtsEnable = checkPowerRTS.Checked;
            serialPort.DtrEnable = checkPowerRTS.Checked;

            try
            {
                serialPort.Open();
                if (verbose)
                    textMessages.AppendText("Open " + selectedCOM.Text + " serial port at " + serialPort.BaudRate + "bd\r\n");
            }
            catch
            {
                textMessages.AppendText("Error: Can't Open " + selectedCOM.Text + " serial port!!!\r\n");
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: transferringFile
        // Parameters: lines = lines of the opened hex file
        // Return: true, if file was correctly transfered in PIC memory
        // Description: - transfert hex to picMem array,
        //              - configure transfert accordingly to PIC family,
        //              - determine blocks to be written,
        //              - then transfert it in PIC flash memory
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private bool transferringFile(string[] lines)
        {
            picMem = new byte[selectedPicInfos.flashMem]; // picMem array size = max flash memory of connected PIC
            for (int a = 0; a < selectedPicInfos.flashMem; a++)
                picMem[a] = 0xFF; // erased byte memory in PIC contains 0xFF
            picEEPROM = new byte[selectedPicInfos.eepromMem]; // picEEPROM array size = max EEPROM memory of connected PIC
            picEEPROMchanged = new bool[selectedPicInfos.eepromMem]; // picEEPROM array size = max EEPROM memory of connected PIC
            for (int a = 0; a < selectedPicInfos.eepromMem; a++)
            {
                picEEPROM[a] = 0xFF; // erased byte memory in PIC contains 0xFF
                picEEPROMchanged[a] = checkEraseEEPROM.Checked;
                isEEPROM = checkEraseEEPROM.Checked;
            }
            picBootFlash = new byte[12288]; // 12KB max for PIC32MX3xx to 7xx family (for PIC32MX1xx to 2xx it's only 3KB)
            for (int a = 0; a < 12288; a++)
                picBootFlash[a] = 0xFF; // erased byte memory in PIC contains 0xFF

            // store data in picMem array
            if (!transfertHexToArray(lines))
                return false;

            // configure transfert and modify code accordingly to PIC family
            if (!configureTransfert())
                return false;

            // erase flash prog memory
            if (selectedPicInfos.family.Equals("F"))
            {
                progressBar.Value = 0;
                textMessages.AppendText("Erasing Flash Memory... \r\n");
                textRawTransfert.AppendText("\r\nErasing Flash Memory... ");
                if (!checkVirtualPIC.Checked)
                    if (!eraseFlash()) // WARNING: erase procedural is different if write Configuration Bytes
                    {
                        textMessages.AppendText("ERROR: Erasing Flash Memory failed!!!\r\n");
                        return false;
                    }
            }

            // Configuration bytes: do the picConfig transfert block by block
            // For PIC32 family, this write must be done as earlier as possible because during "Erase Flash"
            //   config bytes are erased too, so if the user abort the program transfert the PIC won't be
            //   able to enter in a runing state again
            if ((checkWriteConfig.Checked) && (isConfig == true) && (selectedPicInfos.family.Equals("F")))
            {
                //progressBar.Value = 0;
                //textMessages.AppendText("Transferring Config Bytes...\r\n");
                //textRawTransfert.AppendText("\r\nTransferring Config...");

                //for (int memPos = 0x2F90; memPos < 0x3000; memPos += 16)
                //    if (!prepareBlock(memPos, picBootFlash, 1))
                //        return false;
                textMessages.AppendText("Transferring Config Bytes for PIC32 not working yet :-(\r\n");
            }

            // Transferring program
            if ((checkWriteFlashProg.Checked) && (selectedPicInfos.eepromflag != EEP_FILE_EXISTS))
            {
                textMessages.AppendText("Transferring flash...\r\n");

                // do the picBootFlash transfert block by block
                if (selectedPicInfos.family.Equals("F"))
                {
                    progressBar.Value = 0;
                    textMessages.AppendText("   Transferring boot memory...\r\n");
                    textRawTransfert.AppendText("\r\nTransferring boot memory...");
                    // Block size for Boot flash is always 16 bytes, by this way we can write (or not) the configuration bytes
                    for (int memPos = 0x10; memPos < 0x2F90; memPos += 16)
                        if (!prepareBlock(memPos, picBootFlash, 1))
                            return false;
                }

                if (selectedPicInfos.eepromflag != EEP_FILE_EXISTS)
                {
                    // For PIC18 J famly and 16bit PIC E famly
                    // Configuration bytes: do the picConfig transfert block by block
                    byte[] zero = new byte[1];
                    zero[0] = 0;
                    if ((selectedPicInfos.family == "J") || (selectedPicInfos.family == "E"))
                    {
                        if ((checkWriteConfig.Checked) && (isConfig == true) && (!selectedPicInfos.family.Equals("F"))) // ### why !"F" needed???
                        {
                            progressBar.Value = 0;
                            textMessages.AppendText("Transferring Config Bytes...\r\n");
                            textRawTransfert.AppendText("\r\nTransferring Config...");

                            if (!prepareBlock(0, picConfig, 3))
                                return false;
                        }
                        else  // do not the picConfig transfert
                        {
                            progressBar.Value = 0;
                            textMessages.AppendText("Transferring Config Bytes...\r\n");
                            textRawTransfert.AppendText("\r\nTransferring Config...");
                            serialPort.Write(zero, 0, 1);
                            serialPort.Write(zero, 0, 1);
                            zero[0] = (byte)serialPort.ReadByte();
                        }
                    }

                    progressBar.Value = 0;
                    textMessages.AppendText("   Transferring program memory...\r\n");
                    textRawTransfert.AppendText("\r\nTransferring program memory...");
                    // do the picMem transfert block by block
                    for (int memPos = selectedPicInfos.minMemPos; memPos < selectedPicInfos.maxMemPos; memPos += selectedPicInfos.blockSize)
                        if (!prepareBlock(memPos, picMem, 0))
                            return false;
                }
            }

            // write EEPROM: do the picEEPROM transfert block by block
            if (((checkWriteEEPROM.Checked) || (checkEraseEEPROM.Checked)) && (isEEPROM == true))
            {
                progressBar.Value = 0;
                if (checkEraseEEPROM.Checked)
                    textMessages.AppendText("Erasing ");
                if (checkWriteEEPROM.Checked)
                    textMessages.AppendText("Transferring ");
                textMessages.AppendText("EEPROM...\r\n");
                textRawTransfert.AppendText("\r\nTransferring EEPROM...");

                int EEPROMblockSize = selectedPicInfos.dividerHexToMemory;
                if (selectedPicInfos.family == "D")
                    EEPROMblockSize *= 2; //16bit PIC's EEPROM = 16bits
                for (int memPos = 0; memPos < selectedPicInfos.eepromMem; memPos += EEPROMblockSize)
                    if (!prepareBlock(memPos, picEEPROM, 2))
                        return false;
            }

            // Configuration bytes: do the picConfig transfert block by block
            // For other families (not PIC32): for the moment, only for PIC18 family
            if ((checkWriteConfig.Checked) && (isConfig == true) && (!selectedPicInfos.family.Equals("F")) && (!selectedPicInfos.family.Equals("J")) && (!selectedPicInfos.family.Equals("E")))
            {
                progressBar.Value = 0;
                textMessages.AppendText("Transferring Config Bytes...\r\n");
                textRawTransfert.AppendText("\r\nTransferring Config...");

                if (!prepareBlock(0, picConfig, 3))
                    return false;
            }

            progressBar.Value = 0;
            return true;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: prepareBlock
        // Parameters: memPos = start address in flash memory where a block should be written
        //             picMemFlash = array containing bytes from ".hex" file.
        //                           For the moment, there is 2 possible arrays:
        //                           - picMem = program flash memory
        //                           - picBootFlash = boot flash memory (only used for PIC32)
        //             option = tell to the PIC device the special process to use for this block.
        //                      - 0 = write block in program flash memory (all family)
        //                      - 1 = write block in boot flash memory (PIC32)
        //                      - 2 = write block in EEPROM (all family)
        //                      - 3 = write block in Configuration Bytes ("C","J","D","E" family)
        // Return: true, if block was correctly written in PIC flash memory
        // Description: - verify if this block contains bytes to be written (i.e. != 0xFF),
        //              - if yes, call "writeMem" function
        //              - if no, do nothing
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        bool prepareBlock(int memPos, byte[] picMemFlash, byte option)
        {
            bool writeBlock = false;
            byte[] memBlock;
            int blocksize;
            int totalBytesToTransfert;

            if (option == 2)
            {
                blocksize = selectedPicInfos.dividerHexToMemory;
                if (checkEraseEEPROM.Checked)
                    totalBytesToTransfert = selectedPicInfos.eepromMem;
                else
                    totalBytesToTransfert = selectedPicInfos.totalEepromByteInFile;
            }
            else if (option == 3)
            {
                blocksize = selectedPicInfos.configSize;
                totalBytesToTransfert = picConfig.Length;
                writeBlock = true;
            }
            else if (option == 1)
            {
                blocksize = 16;
                totalBytesToTransfert = selectedPicInfos.totalBootByteInFile;
            }
            else
            {
                blocksize = selectedPicInfos.blockSize;
                totalBytesToTransfert = selectedPicInfos.totalByteInFile;
            }

            memBlock = new byte[blocksize];
            for (int i = 0; i < blocksize; i++)
                memBlock[i] = 0xFF; // erased byte memory in PIC contains 0xFF

            for (int j = 0; j < blocksize; j++)
            {
                // verify if this block must be written (i.e. not all data in block == 0xFF)
                if (picMemFlash[memPos + j] != 0xFF)
                {
                    memBlock[j] = picMemFlash[memPos + j];
                    writeBlock = true;
                }
                if ((option == 2) && (picEEPROMchanged[memPos + j]))
                    writeBlock = true;
            }

            if (writeBlock)
            {
                progressBar.Increment(progressBar.Maximum * blocksize / totalBytesToTransfert);

                if (checkShowTransfert.Checked)
                    switch (option)
                    {
                        case 0:
                        case 1:
                            textMessages.AppendText("   write mem pos: 0x" + memPos.ToString("X8") + "(byte)\r\n");
                            break;
                        case 2:
                            if (selectedPicInfos.family == "D")
                                textMessages.AppendText("   write mem pos: 0x" + (memPos + selectedPicInfos.startPosEEPROM * 2).ToString("X8") + "(byte)\r\n");
                            else
                                textMessages.AppendText("   write mem pos: 0x" + (memPos + selectedPicInfos.startPosEEPROM).ToString("X8") + "(byte)\r\n");
                            break;
                        case 3:
                            textMessages.AppendText("   write mem pos: 0x" + (memPos + selectedPicInfos.startPosConfig).ToString("X8") + "(byte)\r\n");
                            break;
                    }

                if (!writeMem(memPos, memBlock, option))
                    return false;
            }
            return true;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: writeMem
        // Parameters: memPos = hex address of the block's first byte to be written
        //             memBlock = buffer containing block's data
        //             option = tell to the PIC device the special process to use for this block.
        //                      - 0 = write block in program flash memory (all family)
        //                      - 1 = write block in boot flash memory (PIC32)
        //                      - 2 = write block in EEPROM (all family)
        //                      - 3 = write block in Configuration Bytes ("C","J","D","E" family)
        // Return: true, if the block was correctly written in PIC memory 
        // Description: write a block to the PIC via serial port
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private bool writeMem(int memPos, byte[] memBlock, byte option)
        {
            byte blockLength = (byte)memBlock.Length;
            byte[] checkSum = new byte[1];
            byte[] bytesToSend = new byte[5];
            byte returnedValue = 0;
            byte uByte = (byte)(((memPos / selectedPicInfos.dividerHexToMemory) >> 16) & 0xFF);
            byte hByte = (byte)(((memPos / selectedPicInfos.dividerHexToMemory) >> 8) & 0xFF);
            byte lByte = (byte)((memPos / selectedPicInfos.dividerHexToMemory) & 0xFF);
            int i;

            if (aborted)
                return false;

            // C8051 family
            if (selectedPicInfos.family == "5")
            {
                bytesToSend[0] = hByte;
                bytesToSend[1] = lByte;
                bytesToSend[2] = blockLength;
                if (!checkVirtualPIC.Checked)
                    serialPort.Write(bytesToSend, 0, 3);

                if (checkShowTransfert.Checked)
                    textMessages.AppendText("      send: EEADRH=0x" + bytesToSend[0].ToString("X2") + ", EEADRL=0x" + bytesToSend[1].ToString("X2") + "(word), block=" + bytesToSend[2].ToString() + "\r\n");

                textRawTransfert.AppendText("\r\nsend: " + bytesToSend[0].ToString("X2") + ", " + bytesToSend[1].ToString("X2") + ", " + bytesToSend[2].ToString("X2") + "; ");

                // add header to checksum
                checkSum[0] = (byte)(hByte + lByte + blockLength);
            }

            // MSP430 family
            if (selectedPicInfos.family == "4")
            {
                bytesToSend[0] = hByte;
                bytesToSend[1] = lByte;
                bytesToSend[2] = blockLength;
                if (!checkVirtualPIC.Checked)
                    serialPort.Write(bytesToSend, 0, 3);

                if (checkShowTransfert.Checked)
                    textMessages.AppendText("      send: EEADRH=0x" + bytesToSend[0].ToString("X2") + ", EEADRL=0x" + bytesToSend[1].ToString("X2") + "(word), block=" + bytesToSend[2].ToString() + "\r\n");

                textRawTransfert.AppendText("\r\nsend: " + bytesToSend[0].ToString("X2") + ", " + bytesToSend[1].ToString("X2") + ", " + bytesToSend[2].ToString("X2") + "; ");

                // add header to checksum
                checkSum[0] = (byte)(hByte + lByte + blockLength);
            }

            // NXP family
            if (selectedPicInfos.family == "3")
            {
                bytesToSend[0] = hByte;
                bytesToSend[1] = lByte;
                bytesToSend[2] = blockLength;
                if (!checkVirtualPIC.Checked)
                    serialPort.Write(bytesToSend, 0, 3);

                if (checkShowTransfert.Checked)
                    textMessages.AppendText("      send: EEADRH=0x" + bytesToSend[0].ToString("X2") + ", EEADRL=0x" + bytesToSend[1].ToString("X2") + "(word), block=" + bytesToSend[2].ToString() + "\r\n");

                textRawTransfert.AppendText("\r\nsend: " + bytesToSend[0].ToString("X2") + ", " + bytesToSend[1].ToString("X2") + ", " + bytesToSend[2].ToString("X2") + "; ");

                // add header to checksum
                checkSum[0] = (byte)(hByte + lByte + blockLength);
            }
            // AVR family
            if (String.Compare(selectedPicInfos.family, "3") < 0)
            {
                if (option == 2) // for EEPROM
                {
                    hByte += (byte)(((selectedPicInfos.startPosEEPROM / selectedPicInfos.dividerHexToMemory) >> 8) & 0xFF);
                    lByte += (byte)((selectedPicInfos.startPosEEPROM / selectedPicInfos.dividerHexToMemory) & 0xFF);
                }
                bytesToSend[0] = hByte;
                bytesToSend[1] = lByte;
                bytesToSend[2] = blockLength;
                if (!checkVirtualPIC.Checked)
                    serialPort.Write(bytesToSend, 0, 3);

                if (checkShowTransfert.Checked)
                    textMessages.AppendText("      send: EEADRH=0x" + bytesToSend[0].ToString("X2") + ", EEADRL=0x" + bytesToSend[1].ToString("X2") + "(word), block=" + bytesToSend[2].ToString() + "\r\n");

                textRawTransfert.AppendText("\r\nsend: " + bytesToSend[0].ToString("X2") + ", " + bytesToSend[1].ToString("X2") + ", " + bytesToSend[2].ToString("X2") + "; ");

                // add header to checksum
                checkSum[0] = (byte)(hByte + lByte + blockLength);
            }

            // PIC10 or PIC12 or PIC16 family
            if (selectedPicInfos.family == "B")
            {
                if (option == 2) // for EEPROM
                {
                    hByte += (byte)(((selectedPicInfos.startPosEEPROM / selectedPicInfos.dividerHexToMemory) >> 8) & 0xFF);
                    lByte += (byte)((selectedPicInfos.startPosEEPROM / selectedPicInfos.dividerHexToMemory) & 0xFF);
                }
                bytesToSend[0] = hByte;
                bytesToSend[1] = lByte;
                bytesToSend[2] = blockLength;
                if (!checkVirtualPIC.Checked)
                    serialPort.Write(bytesToSend, 0, 3);

                if (checkShowTransfert.Checked)
                    textMessages.AppendText("      send: EEADRH=0x" + bytesToSend[0].ToString("X2") + ", EEADRL=0x" + bytesToSend[1].ToString("X2") + "(word), block=" + bytesToSend[2].ToString() + "\r\n");

                textRawTransfert.AppendText("\r\nsend: " + bytesToSend[0].ToString("X2") + ", " + bytesToSend[1].ToString("X2") + ", " + bytesToSend[2].ToString("X2") + "; ");

                // add header to checksum
                checkSum[0] = (byte)(hByte + lByte + blockLength);
            }

            // PIC18F family
            if (selectedPicInfos.family == "C") // PIC18F family
            {
                if (option == 2) // for EEPROM
                {
                    uByte += (byte)((selectedPicInfos.startPosEEPROM >> 16) & 0xFF);
                    hByte += (byte)((selectedPicInfos.startPosEEPROM >> 8) & 0xFF);
                    lByte += (byte)(selectedPicInfos.startPosEEPROM & 0xFF);
                }
                if (option == 3) // for Configuration bytes
                {
                    uByte += (byte)((selectedPicInfos.startPosConfig >> 16) & 0xFF);
                    hByte += (byte)((selectedPicInfos.startPosConfig >> 8) & 0xFF);
                    lByte += (byte)(selectedPicInfos.startPosConfig & 0xFF);
                }
                // the pic must receive 4 bytes:
                // TBLPTRU TBLPTRH TBLPTRL BlockLength
                bytesToSend[0] = uByte;
                bytesToSend[1] = hByte;
                bytesToSend[2] = lByte;
                bytesToSend[3] = blockLength;
                if (!checkVirtualPIC.Checked)
                    serialPort.Write(bytesToSend, 0, 4);

                if (checkShowTransfert.Checked)
                    textMessages.AppendText("      send: TBLPTRU=0x" + bytesToSend[0].ToString("X2") + ", TBLPTRH=0x" + bytesToSend[1].ToString("X2") + ", TBLPTRL=0x" + bytesToSend[2].ToString("X2") + ", block=" + bytesToSend[3].ToString() + "\r\n");

                textRawTransfert.AppendText("\r\nsend: " + bytesToSend[0].ToString("X2") + ", " + bytesToSend[1].ToString("X2") + ", " + bytesToSend[2].ToString("X2") + ", " + bytesToSend[3].ToString("X2") + "; ");

                // add header to checksum
                checkSum[0] = (byte)(uByte + hByte + lByte + blockLength);
            }

            // PIC18F J family
            if (selectedPicInfos.family == "J") // PIC18F J family
            {
                if (option == 3) // for Configuration bytes
                {
                    uByte += (byte)((selectedPicInfos.startPosConfig >> 16) & 0xFF);
                    hByte += (byte)((selectedPicInfos.startPosConfig >> 8) & 0xFF);
                    lByte += (byte)(selectedPicInfos.startPosConfig & 0xFF);
                }
                // the pic must receive 4 bytes:
                // TBLPTRU TBLPTRH TBLPTRL BlockLength
                bytesToSend[0] = uByte;
                bytesToSend[1] = hByte;
                bytesToSend[2] = lByte;
                bytesToSend[3] = blockLength;
                if (!checkVirtualPIC.Checked)
                    serialPort.Write(bytesToSend, 0, 4);

                if (checkShowTransfert.Checked)
                    textMessages.AppendText("      send: TBLPTRU=0x" + bytesToSend[0].ToString("X2") + ", TBLPTRH=0x" + bytesToSend[1].ToString("X2") + ", TBLPTRL=0x" + bytesToSend[2].ToString("X2") + ", block=" + bytesToSend[3].ToString() + "\r\n");

                textRawTransfert.AppendText("\r\nsend: " + bytesToSend[0].ToString("X2") + ", " + bytesToSend[1].ToString("X2") + ", " + bytesToSend[2].ToString("X2") + ", " + bytesToSend[3].ToString("X2") + "; ");

                // add header to checksum
                checkSum[0] = (byte)(uByte + hByte + lByte + blockLength);
            }
            // 16bit PIC D E family
            if ((selectedPicInfos.family == "D") || (selectedPicInfos.family == "E"))
            {
                int _blockLength = memBlock.Length;
                if (option == 0) // for Flash
                    _blockLength = _blockLength * 3 / 4;
                if (option == 2) // for EEPROM
                {
                    uByte += (byte)((selectedPicInfos.startPosEEPROM >> 16) & 0xFF);
                    hByte += (byte)((selectedPicInfos.startPosEEPROM >> 8) & 0xFF);
                    lByte += (byte)(selectedPicInfos.startPosEEPROM & 0xFF);
                }
                if (option == 3) // for Configuration bytes
                {
                    uByte += (byte)((selectedPicInfos.startPosConfig >> 16) & 0xFF);
                    hByte += (byte)((selectedPicInfos.startPosConfig >> 8) & 0xFF);
                    lByte += (byte)(selectedPicInfos.startPosConfig & 0xFF);
                    if (selectedPicInfos.family == "D")
                        _blockLength = _blockLength / 2;
                    else // E family
                        _blockLength = _blockLength * 3 / 4;
                }
                // the pic must receive 4 bytes:
                // TBLPTRL TBLPTRH TBLPTRU BlockLength
                bytesToSend[0] = lByte;
                bytesToSend[1] = hByte;
                bytesToSend[2] = uByte;
                bytesToSend[3] = (byte)(_blockLength);
                if (!checkVirtualPIC.Checked)
                    serialPort.Write(bytesToSend, 0, 4);

                if (checkShowTransfert.Checked)
                    textMessages.AppendText("      send: TBLPTRU=0x" + bytesToSend[2].ToString("X2") + ", TBLPTRH=0x" + bytesToSend[1].ToString("X2") + ", TBLPTRL=0x" + bytesToSend[0].ToString("X2") + ", block=" + bytesToSend[3].ToString() + "\r\n");

                textRawTransfert.AppendText("\r\nsend: " + bytesToSend[0].ToString("X2") + ", " + bytesToSend[1].ToString("X2") + ", " + bytesToSend[2].ToString("X2") + ", " + bytesToSend[3].ToString("X2") + "; ");

                // add header to checksum
                checkSum[0] = (byte)(lByte + hByte + uByte + _blockLength);
            }
            // PIC32 family
            if (selectedPicInfos.family == "F")
            {
                bytesToSend[0] = blockLength;
                bytesToSend[1] = option; // 1=boot or 0=program flash memory
                bytesToSend[2] = uByte;
                bytesToSend[3] = hByte;
                bytesToSend[4] = lByte;
                if (!checkVirtualPIC.Checked)
                    for (i = 0; i < 5; i++)
                        serialPort.Write(bytesToSend, i, 1);

                if (checkShowTransfert.Checked)
                    textMessages.AppendText("      send: zone mem code=0x" + bytesToSend[1].ToString("X2") + ", EEADRU=0x" + bytesToSend[2].ToString("X2") + ", EEADRH=0x" + bytesToSend[3].ToString("X2") + ", EEADRL=0x" + bytesToSend[4].ToString("X2") + ", block size=" + bytesToSend[0].ToString() + "\r\n");

                textRawTransfert.AppendText("\r\nsend: " + bytesToSend[0].ToString("X2") + ", " + bytesToSend[1].ToString("X2") + ", " + bytesToSend[2].ToString("X2") + ", " + bytesToSend[3].ToString("X2") + ", " + bytesToSend[4].ToString("X2") + "; ");

                // add header to checksum
                checkSum[0] = (byte)(uByte + hByte + lByte + blockLength + option);
            }

            // Common for every families:
            /////////////////////////////

            if ((selectedPicInfos.family == "D") || (selectedPicInfos.family == "E"))
            {
                if ((option == 3) && (selectedPicInfos.family == "D")) // D family Config bytes
                {
                    for (i = 0; i < memBlock.Length; i++)
                    {
                        if (!((((i + 2) % 4) == 0) || (((i + 1) % 4) == 0)))
                        {
                            // Calculate checksum
                            checkSum[0] = (byte)(checkSum[0] + memBlock[i]);

                            // = s.write(chr(memBlock[i])) ?
                            if (!checkVirtualPIC.Checked)
                                serialPort.Write(memBlock, i, 1);
                            textRawTransfert.AppendText(memBlock[i].ToString("X2") + ", ");

                            if (checkShowTransfert.Checked)
                                textMessages.AppendText(" " + memBlock[i].ToString("X2"));
                        }
                    }
                }
                if (option == 2) // EEPROM (D family)
                {
                    // Calculate checksum
                    checkSum[0] = (byte)(checkSum[0] + memBlock[0] + memBlock[1]);

                    if (!checkVirtualPIC.Checked)
                        serialPort.Write(memBlock, 0, 2);
                    textRawTransfert.AppendText(memBlock[0].ToString("X2") + ", " + memBlock[1].ToString("X2") + ", ");

                    if (checkShowTransfert.Checked)
                        textMessages.AppendText(" " + memBlock[0].ToString("X2") + " " + memBlock[1].ToString("X2"));
                }
                if ((option == 0) || ((option == 3) && (selectedPicInfos.family == "E"))) // Flash or E family Config
                {
                    for (i = 0; i < memBlock.Length; i++)
                    {
                        if (!(((i + 1) % 4) == 0))
                        {
                            // Calculate checksum
                            checkSum[0] = (byte)(checkSum[0] + memBlock[i]);

                            // = s.write(chr(memBlock[i])) ?
                            if (!checkVirtualPIC.Checked)
                                serialPort.Write(memBlock, i, 1);
                            textRawTransfert.AppendText(memBlock[i].ToString("X2") + ", ");

                            if (checkShowTransfert.Checked)
                                textMessages.AppendText(" " + memBlock[i].ToString("X2"));
                        }
                    }
                }
            }
            else // for other families (not "D" or "E")
            {
                for (i = 0; i < blockLength; i++)
                {
                    // Calculate checksum
                    checkSum[0] = (byte)(checkSum[0] + memBlock[i]);

                    // = s.write(chr(memBlock[i])) ?
                    if (!checkVirtualPIC.Checked)
                        serialPort.Write(memBlock, i, 1);
                    textRawTransfert.AppendText(memBlock[i].ToString("X2") + ", ");

                    if (checkShowTransfert.Checked)
                        textMessages.AppendText(" " + memBlock[i].ToString("X2"));
                }
            }
            if (checkShowTransfert.Checked)
                textMessages.AppendText("\r\n");

            checkSum[0] = (byte)((-checkSum[0]) & 0xFF);
            // = s.write(chr(checkSum)) ?###
            if (!checkVirtualPIC.Checked)
                serialPort.Write(checkSum, 0, 1);
            textRawTransfert.AppendText(checkSum[0].ToString("X2") + ", ");

            try
            {
                if (!checkVirtualPIC.Checked)
                    returnedValue = (byte)serialPort.ReadByte();
                else
                    returnedValue = (byte)Convert.ToInt32(Encoding.ASCII.GetBytes(textVirtualPICFam.Text.ToUpper())[0]);
                textRawTransfert.AppendText("\r\nreceive: " + returnedValue.ToString("X2") + ", ");

                // CRC OK code is the device Family (or 'K' for old firmwares). 'N' is for CRC error
                if (((returnedValue >= 0x30) && (returnedValue <= 0x39)) // 0 to 9
                    || ((returnedValue >= 0x41) && (returnedValue <= 0x5A) && (returnedValue != 0x4E))) // A to Z (except 'N' as it can't be a Family, it's only for CRC error)
                {
                    if (checkShowTransfert.Checked)
                        textMessages.AppendText("      CRC OK (0x" + checkSum[0].ToString("X2") + ")\r\n");
                    return true;
                }
                else if (returnedValue == 0x4E) // 0x4E = "N"
                {
                    if (checkShowTransfert.Checked)
                        textMessages.AppendText("      CRC Failed at memory position: 0x" + memPos.ToString("X4") + "\r\n");
                    return false;
                }
                else
                {
                    if (checkShowTransfert.Checked)
                        textMessages.AppendText("      Unknown answer\r\n");
                    return false;
                }
            }
            catch
            {
                if (option == 3)
                {
                    textMessages.AppendText("      No CRC received. The bootloader must be destroyed by the new configuration bytes, but your application will work as expected.\r\n");
                }
                else
                    textMessages.AppendText("      no answer\r\n");
                return false;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: transfertHexToArray
        // Parameters: lines = lines of the opened hex file
        // Return: bool "hasData" they are data in the hex file
        // Description: store data from ".hex" file to picMem or picBootFlash array depending on 
        //              extended address value
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private bool transfertHexToArray(string[] lines)
        {
            string pic16Serie = "Unknown"; // PIC family the hex belongs (for check ".hex" purpose
            int address = 0; // address red in the hex file
            int extendedAddress = 0; // extented address for INHX32 hex files (PIC18 & PIC32)
            int recordType = 0;
            int lineByteCount = 0; // nb of bytes in a line
            bool hasData = false; // they are data in the hex file
            bool isCodeSection = true; // if we are in code section so transfert byte from hex to array
            bool isBootSection = false; // only for PIC32, if we are in boot flash mem
            bool hasPIC32JumpMoved = false; // only for PIC32, boot section has priority to move the jump from reset vector to specified place
            bool canBeMikroC32; // if true, hex file created by MikroC32 (jump code must be modified)
            bool jumpMikroC32 = false; // tell if jump has been modified for MikroC32
            bool isErasingBootloader; // tell if application hex is too big and will erase the bootloader
            bool hasCodeAdded = false; // only for display "hex file" in debug
            byte[] changedJumpMikroC32 = { 0xc0, 0xbf, 0x1a, 0x3c, 
                                           0x10, 0x00, 0x5a, 0x27, 
                                           0x08, 0x00, 0x40, 0x03, 
                                           0x00, 0x00, 0x00, 0x00 };

            // for 24bit PIC D family
            if (selectedPicInfos.family == "D")
            {
                selectedPicInfos.configSize = familyPicD_ConfigBytesSize * 2;
                picConfig = new byte[selectedPicInfos.configSize];
                for (int a = 0; a < selectedPicInfos.configSize; a++)
                    picConfig[a] = 0xFF; // erased byte memory in PIC contains 0xFF
            }
            // for 24bit PIC E family
            if (selectedPicInfos.family == "E")
            {
                selectedPicInfos.configSize = familyPicE_ConfigBytesSize * 2;
                picConfig = new byte[selectedPicInfos.configSize];
                for (int a = 0; a < selectedPicInfos.configSize; a++)
                    picConfig[a] = 0xFF; // erased byte memory in PIC contains 0xFF
            }

            foreach (string line in lines)
            {
                if (aborted)
                    return false;

                if (line.ToUpper() == ":10000000FCFFBD27000000700000007000000070C1") // first line in MikroC32 generated hex file
                    canBeMikroC32 = true;
                else
                    canBeMikroC32 = false;

                if (line.Substring(0, 1).Trim() == ":")
                {
                    // Read the register address 
                    // Have in mind that the physical PIC address is half of the
                    // address registered in the .hex file for the 16F familly
                    address = Convert.ToInt32(line.Substring(3, 4).Trim(), 16); // convert hexa address (":llAAAA...") to decimal

                    // EEPROM base address for ATtiny family
                    if ((selectedPicInfos.eepromflag == EEP_FILE_EXISTS) && (selectedPicInfos.family == "1"))
                        address = 2 * address + 0x4200;

                    // EEPROM base address for ATmega family
                    if ((selectedPicInfos.eepromflag == EEP_FILE_EXISTS) && (selectedPicInfos.family == "2"))
                        address = 2 * address + 0x100200;

                    // Read the register type...
                    recordType = Convert.ToInt32(line.Substring(7, 2).Trim(), 16); // convert record type hexa (":llaaaaTT...") to decimal
                    // ...then only use data register in code section
                    if ((recordType == 0) && (isCodeSection || isBootSection))
                    {
                        // Read the byte count
                        lineByteCount = Convert.ToInt32(line.Substring(1, 2).Trim(), 16); // convert bytes in line hexa string (":LL...") to decimal integer

                        if (checkShowFile.Checked)
                        {
                            textMessages.AppendText(line + "\r\n");
                            textMessages.AppendText("0x" + address.ToString("X4") + ": ");
                        }

                        for (int i = 9; i < (9 + 2 * lineByteCount); i += 2) // 9 = 1st data byte (after ":llaaaatt")
                        {
                            if (isCodeSection)
                            {
                                // verify if we don't write on bootloader firmware
                                if (((String.Compare(selectedPicInfos.family, "A") >= 0) && ((extendedAddress + address) > (selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize)))
                                    || ((String.Compare(selectedPicInfos.family, "A") < 0) && ((extendedAddress + address) > (selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize + 8))))
                                {
                                    isErasingBootloader = true;

                                    // AVR ATtiny
                                    if ((extendedAddress == 0) && (selectedPicInfos.family == "1"))
                                    {
                                        if ((extendedAddress + address) >= 0x4200)
                                        {
                                            // 0x4000 (word) is just a flag for the tinybld firmware. 
                                            // It doesn't care of the real address.
                                            selectedPicInfos.startPosEEPROM = 0x8000;
                                            picEEPROM[extendedAddress + address - 0x4200] = Convert.ToByte(line.Substring(i, 2).Trim(), 16);
                                            picEEPROMchanged[extendedAddress + address - 0x4200] = true;
                                            isEEPROM = true; // there is EEPROM
                                            selectedPicInfos.totalEepromByteInFile++;
                                            if (checkShowFile.Checked)
                                                textMessages.AppendText(picEEPROM[extendedAddress + address - 0x4200].ToString("X2") + " ");
                                            // ### usefulness?
                                            if (selectedPicInfos.eepromflag == EEP_FILE_EXISTS)
                                            {
                                                address += 1;
                                                picEEPROM[extendedAddress + address - 0x4200] = 0;
                                            }
                                            isErasingBootloader = false;
                                        }
                                    }

                                    // AVR ATmega
                                    if ((extendedAddress == 0) && (selectedPicInfos.family == "2"))
                                    {
                                        if ((extendedAddress + address) >= 0x100200)
                                        {
                                            // 0x4000 (word) is just a flag for the tinybld firmware. 
                                            // It doesn't care of the real address.
                                            selectedPicInfos.startPosEEPROM = 0x8000;
                                            picEEPROM[extendedAddress + address - 0x100200] = Convert.ToByte(line.Substring(i, 2).Trim(), 16);
                                            picEEPROMchanged[extendedAddress + address - 0x100200] = true;
                                            isEEPROM = true; // there is EEPROM
                                            selectedPicInfos.totalEepromByteInFile++;
                                            if (checkShowFile.Checked)
                                                textMessages.AppendText(picEEPROM[extendedAddress + address - 0x100200].ToString("X2") + " ");
                                            // ### usefulness?
                                            if (selectedPicInfos.eepromflag == EEP_FILE_EXISTS)
                                            {
                                                address += 1;
                                                picEEPROM[extendedAddress + address - 0x100200] = 0;
                                            }
                                            isErasingBootloader = false;
                                        }
                                    }

                                    // enhanced PIC16
                                    if ((extendedAddress >= 0x10000) && (selectedPicInfos.family == "B"))
                                    {
                                        if ((extendedAddress + address) >= 0x1E000)
                                        {
                                            selectedPicInfos.startPosEEPROM = 0x1E000;
                                            picEEPROM[extendedAddress + address - 0x1E000] = Convert.ToByte(line.Substring(i, 2).Trim(), 16);
                                            picEEPROMchanged[extendedAddress + address - 0x1E000] = true;
                                            isEEPROM = true; // there is EEPROM
                                            selectedPicInfos.totalEepromByteInFile++;
                                            if (checkShowFile.Checked)
                                                textMessages.AppendText(picEEPROM[extendedAddress + address - 0x1E000].ToString("X2") + " ");
                                            isErasingBootloader = false;
                                            pic16Serie = "PIC16Enh";
                                        }
                                        if (((extendedAddress + address) >= 0x1000E) && ((extendedAddress + address) < 0x10020)) // (max address for config 0x10020 arbitrary)
                                        {
                                            textMessages.AppendText("   Warning: Config found just writing data\r\n");
                                            isErasingBootloader = false;
                                            pic16Serie = "PIC16Enh";
                                        }
                                        if (((extendedAddress + address) >= 0x10000) && ((extendedAddress + address) < 0x10008))
                                        {
                                            textMessages.AppendText("   Warning: User ID bytes found, just writing data\r\n");
                                            isErasingBootloader = false;
                                            pic16Serie = "PIC16Enh";
                                        }
                                    }
                                    // normal PIC16
                                    if ((extendedAddress == 0) && (selectedPicInfos.family == "B"))
                                    {
                                        if ((extendedAddress + address) >= 0x4200)
                                        {
                                            // 0x4000 (word) is just a flag for the tinybld firmware. 
                                            // It doesn't care of the real address.
                                            selectedPicInfos.startPosEEPROM = 0x8000; // 0x8000 (byte) = 0x4000 (word)
                                            picEEPROM[extendedAddress + address - 0x4200] = Convert.ToByte(line.Substring(i, 2).Trim(), 16);
                                            picEEPROMchanged[extendedAddress + address - 0x4200] = true;
                                            isEEPROM = true; // there is EEPROM
                                            selectedPicInfos.totalEepromByteInFile++;
                                            if (checkShowFile.Checked)
                                                textMessages.AppendText(picEEPROM[extendedAddress + address - 0x4200].ToString("X2") + " ");
                                            isErasingBootloader = false;
                                            pic16Serie = "PIC16Nor";
                                        }
                                        if (((extendedAddress + address) >= 0x400E) && ((extendedAddress + address) < 0x4020)) // = 0x2007 word (max address for config 0x4020 arbitrary)
                                        {
                                            textMessages.AppendText("   Warning: Config found just writing data\r\n");
                                            isErasingBootloader = false;
                                            pic16Serie = "PIC16Nor";
                                        }
                                        if (((extendedAddress + address) >= 0x4000) && ((extendedAddress + address) < 0x4008)) // = 0x2000 word
                                        {
                                            textMessages.AppendText("   Warning: User ID bytes found, just writing data\r\n");
                                            isErasingBootloader = false;
                                            pic16Serie = "PIC16Nor";
                                        }
                                    }
                                    // for PIC18: EEPROM 
                                    if ((extendedAddress == 0x00F00000) && (selectedPicInfos.family == "C"))
                                    {
                                        // 0x400000 (byte) is just a flag for the tinybld firmware. 
                                        // It doesn't care of the real address.
                                        selectedPicInfos.startPosEEPROM = 0x400000;
                                        picEEPROM[extendedAddress + address - 0x00F00000] = Convert.ToByte(line.Substring(i, 2).Trim(), 16);
                                        picEEPROMchanged[extendedAddress + address - 0x00F00000] = true;
                                        isEEPROM = true; // there is EEPROM
                                        selectedPicInfos.totalEepromByteInFile++;
                                        if (checkShowFile.Checked)
                                            textMessages.AppendText(picEEPROM[extendedAddress + address - 0x00F00000].ToString("X2") + " ");
                                        isErasingBootloader = false;
                                    }
                                    // for 24bit PIC D family: EEPROM
                                    if ((extendedAddress == 0x00FF0000) && (selectedPicInfos.family == "D"))
                                    {
                                        // 0x400000 (word) is just a flag for the tinybld firmware. 
                                        // It doesn't care of the real address.
                                        selectedPicInfos.startPosEEPROM = 0x800000 - selectedPicInfos.eepromMem;
                                        picEEPROM[extendedAddress + address - (0x800000 - selectedPicInfos.eepromMem) * 2] = Convert.ToByte(line.Substring(i, 2).Trim(), 16);
                                        picEEPROMchanged[extendedAddress + address - (0x800000 - selectedPicInfos.eepromMem) * 2] = true;
                                        isEEPROM = true; // there is EEPROM
                                        selectedPicInfos.totalEepromByteInFile++;
                                        if (checkShowFile.Checked)
                                            textMessages.AppendText(picEEPROM[extendedAddress + address - (0x800000 - selectedPicInfos.eepromMem) * 2].ToString("X2") + " ");
                                        isErasingBootloader = false;
                                    }
                                    // for PIC18: Configuration Bytes 
                                    if ((extendedAddress == 0x00300000) && (selectedPicInfos.family == "C"))
                                    {
                                        // 0x800000 (byte) is just a flag for the tinybld firmware. 
                                        // It doesn't care of the real address.
                                        if (address < familyPicC_ConfigBytesSize) // for handle bug from Great Cow Basic generation ".hex" file
                                        {
                                            selectedPicInfos.startPosConfig = 0x800000 | extendedAddress;
                                            picConfig[extendedAddress + address - 0x00300000] = Convert.ToByte(line.Substring(i, 2).Trim(), 16);
                                            isConfig = true; // there is Configuration Bytes
                                            if (checkShowFile.Checked)
                                                textMessages.AppendText(picConfig[extendedAddress + address - 0x00300000].ToString("X2") + " ");
                                        }
                                        isErasingBootloader = false;
                                    }
                                    // for PIC18 J: Configuration Bytes
                                    if ((address >= (selectedPicInfos.flashMem - 8)) && (selectedPicInfos.family == "J"))
                                    {
                                        // 0x800000 (byte) is just a flag for the tinybld firmware. 
                                        // It doesn't care of the real address.
                                        selectedPicInfos.startPosConfig = (0x800000 | (selectedPicInfos.flashMem - 8));
                                        picConfig[address - (selectedPicInfos.flashMem - 8)] = Convert.ToByte(line.Substring(i, 2).Trim(), 16);
                                        isConfig = true; // there is Configuration Bytes
                                        if (checkShowFile.Checked)
                                            textMessages.AppendText(picConfig[extendedAddress + address - 0x00300000].ToString("X2") + " ");
                                        isErasingBootloader = false;
                                    }
                                    // for 16bit PIC D family: Configuration Bytes
                                    if ((extendedAddress == 0x001F00000) && (selectedPicInfos.family == "D"))
                                    {
                                        // 0x800000 (word) is just a flag for the tinybld firmware. 
                                        // It doesn't care of the real address.
                                        if (address < familyPicD_ConfigBytesSize * 2) // for handle bug from Great Cow Basic generation ".hex" file
                                        {
                                            selectedPicInfos.startPosConfig = 0xF80000;
                                            picConfig[extendedAddress + address - 0x001F00000] = Convert.ToByte(line.Substring(i, 2).Trim(), 16);
                                            isConfig = true; // there is Configuration Bytes
                                            if (checkShowFile.Checked)
                                                textMessages.AppendText(picConfig[extendedAddress + address - 0x001F00000].ToString("X2") + " ");
                                        }
                                        isErasingBootloader = false;
                                    }
                                    // for 16bit PIC E family: Configuration Bytes
                                    if (((extendedAddress + address) >= (selectedPicInfos.flashMem - selectedPicInfos.configSize)) && (selectedPicInfos.family == "E"))
                                    {
                                        // 0x800000 (byte) is just a flag for the tinybld firmware. 
                                        // It doesn't care of the real address.
                                        selectedPicInfos.startPosConfig = (selectedPicInfos.flashMem - selectedPicInfos.configSize) / 2;
                                        picConfig[extendedAddress + address - (selectedPicInfos.flashMem - selectedPicInfos.configSize)] = Convert.ToByte(line.Substring(i, 2).Trim(), 16);
                                        isConfig = true; // there is Configuration Bytes
                                        if (checkShowFile.Checked)
                                            textMessages.AppendText(picConfig[extendedAddress + address - (selectedPicInfos.flashMem - selectedPicInfos.configSize)].ToString("X2") + " ");
                                        isErasingBootloader = false;
                                    }
                                    if (isErasingBootloader)
                                    {
                                        textMessages.AppendText("Error: hex file too large, writing bootloader firmware!!!\r\n");
                                        return false;
                                    }
                                }
                                else // we aren't writing on bootloader firmware area, so it's user's firmware to write in the device's program flash memory
                                {
                                    // for PIC16Fxx and PIC18 families: (it will be done for PIC16Fxxx later in "configureTransfert" function) 
                                    // move the first 4 words (those before interrupts) to the needed location (max mem - 100 words)
                                    // Preparation for GOTO to program start
                                    if (((extendedAddress + address) < 8) && ((selectedPicInfos.family == "B") || (selectedPicInfos.family == "C") || (selectedPicInfos.family == "J") || (String.Compare(selectedPicInfos.family, "A") < 0)))
                                        picMem[extendedAddress + address + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = Convert.ToByte(line.Substring(i, 2).Trim(), 16);
                                    // if it is PIC32 move 0x10 first byte from 0x6000 to selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize - 0x10
                                    // if not already done from isBootSection
                                    // (it's only usefull for HEX files created with special ".ld" for boot programs of Microchip HID Bootloader)
                                    if (((extendedAddress + address) >= 0x6000) && ((extendedAddress + address) < 0x6010)
                                        && (selectedPicInfos.family == "F") && (hasPIC32JumpMoved == false))
                                    {
                                        picMem[(extendedAddress + address - 0x6000) + selectedPicInfos.flashMem - (selectedPicInfos.bootloaderSize + 0x10)] = Convert.ToByte(line.Substring(i, 2).Trim(), 16);
                                    }
                                    // store data in picMem (it uses hex file address)
                                    if (selectedPicInfos.eepromflag != EEP_FILE_EXISTS)
                                        picMem[extendedAddress + address] = Convert.ToByte(line.Substring(i, 2).Trim(), 16);

                                    selectedPicInfos.totalByteInFile++;
                                    hasCodeAdded = true;
                                }
                            }
                            if (isBootSection)
                            {
                                // store data in picBootFlash (it uses hex file address)
                                if (selectedPicInfos.family.Equals("F")) // not really usefull. It's there for uniformization purpose and if there'll be other device families using boot flash
                                {
                                    // move 0x10 first byte from 0x0000 to selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize - 0x10
                                    // for goto to program start
                                    if ((extendedAddress + address) < 0x10)
                                    {
                                        if (canBeMikroC32 == true)
                                        {
                                            jumpMikroC32 = true;
                                            picMem[extendedAddress + address + selectedPicInfos.flashMem - (selectedPicInfos.bootloaderSize + 0x10)] = changedJumpMikroC32[extendedAddress + address];
                                        }
                                        else
                                            picMem[extendedAddress + address + selectedPicInfos.flashMem - (selectedPicInfos.bootloaderSize + 0x10)] = Convert.ToByte(line.Substring(i, 2).Trim(), 16);
                                        hasPIC32JumpMoved = true; // HEX file was not created with special ".ld" for boot programs of Microchip HID Bootloader
                                    }

                                    picBootFlash[extendedAddress + address] = Convert.ToByte(line.Substring(i, 2).Trim(), 16);
                                    if (address >= 0x2FF0)
                                    {
                                        if (checkWriteConfig.Checked == true)
                                            isConfig = true;
                                        else
                                            textMessages.AppendText("   Warning: Config found just writing data\r\n");
                                    }
                                }
                                selectedPicInfos.totalBootByteInFile++;
                                hasCodeAdded = true;
                            }

                            if (hasCodeAdded)
                                if (checkShowFile.Checked)
                                    textMessages.AppendText(picMem[address].ToString("X2") + " ");

                            address++;
                        }
                        if (checkShowFile.Checked)
                            textMessages.AppendText("\r\n");

                        hasData = true;
                        hasCodeAdded = false;
                    }
                    else if (recordType == 4) // special data (ID bytes, Config bytes, etc...)
                    {
                        extendedAddress = Convert.ToInt32(line.Substring(9, 4).Trim(), 16);

                        if ((checkShowFile.Checked) && !((selectedPicInfos.family == "F") && (extendedAddress == 0)))
                            textMessages.AppendText("extended address: 0x" + extendedAddress.ToString("X4") + "\r\n");
                        // for PIC16 and PIC18 and 16bit PIC:
                        if ((selectedPicInfos.family == "B") || (selectedPicInfos.family == "C") || (selectedPicInfos.family == "J") || (selectedPicInfos.family == "D") || (selectedPicInfos.family == "E"))
                            extendedAddress = (extendedAddress << 16);
                        // for PIC18: Configuration Bytes 
                        if ((extendedAddress == 0x00300000) && (selectedPicInfos.family == "C"))
                        {
                            if (checkShowFile.Checked)
                                textMessages.AppendText("-> Configuration Bytes:\r\n");
                            selectedPicInfos.configSize = familyPicC_ConfigBytesSize; // picConfig array size = 16 (for PIC18 family)
                            picConfig = new byte[selectedPicInfos.configSize];
                            for (int a = 0; a < selectedPicInfos.configSize; a++)
                                picConfig[a] = 0xFF; // erased byte memory in PIC contains 0xFF
                        }
                        // for PIC18: 
                        if ((extendedAddress == 0x00200000) && (selectedPicInfos.family == "C"))
                        {
                            textMessages.AppendText("   Warning: User ID bytes found, just writing data\r\n");
                            isCodeSection = false;
                            isBootSection = false;
                        }
                        // for PIC18: 
                        if ((extendedAddress < 0x000F) && ((selectedPicInfos.family == "C") || (selectedPicInfos.family == "J"))) // 0x000F arbitrary, for the moment PIC18 can only have <=0x0002 (if one day memory > to 128kB)
                        {
                            isCodeSection = true;
                            isBootSection = false;
                        }
                        // for PIC18 J: Configuration Bytes
                        if ((extendedAddress == 0x00000000) && (selectedPicInfos.family == "J"))
                        {
                            if (checkShowFile.Checked)
                                textMessages.AppendText("-> Configuration Bytes:\r\n");
                            selectedPicInfos.configSize = familyPicJ_ConfigBytesSize; // picConfig array size = 8 (for PIC18 J family)
                            picConfig = new byte[selectedPicInfos.configSize];
                            for (int a = 0; a < selectedPicInfos.configSize; a++)
                                picConfig[a] = 0xFF; // erased byte memory in PIC contains 0xFF
                        }
                        // for 16bit PIC D family: Configuration Bytes
                        if ((checkShowFile.Checked) && (extendedAddress == 0x01F00000) && (selectedPicInfos.family == "D"))
                            textMessages.AppendText("-> Configuration Bytes:\r\n");
                        // for PIC32:
                        if ((extendedAddress >= 0x1D00) && (extendedAddress < 0x1E00)) // address extension = 0x1D00 to 0x1D07 (PIC32 program flash mem), reserved from 0x1D08 to 0x1F80 (if one day memory > to 512kB) 
                        {
                            isCodeSection = true;
                            isBootSection = false;
                            extendedAddress = ((extendedAddress & 0x00FF) << 16);
                        }
                        // for PIC32:
                        if (extendedAddress == 0x1FC0)
                        {
                            isCodeSection = false;
                            isBootSection = true;
                            extendedAddress = 0; // not really used
                        }
                    }
                }
            }

            if (jumpMikroC32 == true)
                textMessages.AppendText("   mikroC32 jump fixed.\r\n");

            if (!hasData)
                textMessages.AppendText("Error: this hex file contains no data!!!\r\n");

            // If "erase EEPROM" checked and no EEPROM data found in ".hex" 
            // then we need to know the right "startPosEEPROM"
            if (checkEraseEEPROM.Checked == true)
            {
                // if "EEPROM" unchecked and if they are EEPROM data in ".hex" file, they are no longer written
                if ((isEEPROM == true) && (checkWriteEEPROM.Checked == false))
                {
                    for (int a = 0; a < selectedPicInfos.eepromMem; a++)
                        picEEPROM[a] = 0xFF; // erased byte memory in PIC contains 0xFF
                }

                isEEPROM = true;
                if ((selectedPicInfos.family == "1") || (selectedPicInfos.family == "2"))
                    selectedPicInfos.startPosEEPROM = 0x8000;
                if (selectedPicInfos.family == "B")
                {
                    if (pic16Serie == "PIC16Nor")
                        selectedPicInfos.startPosEEPROM = 0x8000;
                    if (pic16Serie == "PIC16Enh")
                        selectedPicInfos.startPosEEPROM = 0x1E000;
                    if (pic16Serie == "Unknown") // ### should create different families for normal and enhanced PIC16???
                    {
                        textMessages.AppendText("Warning: Can't determine the device, EEPROM won't be erased.\r\n");
                        isEEPROM = false;
                    }
                }
                if (selectedPicInfos.family == "C")
                    selectedPicInfos.startPosEEPROM = 0x400000;
                if ((selectedPicInfos.family == "F") || (selectedPicInfos.family == "J") || (selectedPicInfos.family == "E"))
                {
                    textMessages.AppendText("Warning: No EEPROM memory in this device.\r\n");
                    isEEPROM = false;
                }
            }

            return hasData;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: configureTransfert
        // Parameters: none
        // Return: true, if the PIC family transfert code exists 
        // Description: configure transfert and modify code accordingly to PIC family
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private bool configureTransfert()
        {
            int gotoAsmAddress;
            byte hhGotoAsmAddress;
            byte hGotoAsmAddress;
            byte lGotoAsmAddress;

            // C8051
            // write block size variable
            if (selectedPicInfos.family == "5")
            {
                int extendedAddress = 0;

                selectedPicInfos.dividerHexToMemory = 1; // with C8051 family physical address = hex address
                selectedPicInfos.maxMemPos = selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize + 4; //in bytes not word (maxpos=max_flash-100+4) (+4 bytes is for jump to program start address)
                selectedPicInfos.minMemPos = 0;

                picMem[extendedAddress + 0 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMem[0];
                picMem[extendedAddress + 1 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMem[1];
                picMem[extendedAddress + 2 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMem[2];
                picMem[extendedAddress + 3 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;

                // GOTO to bootloader location
                gotoAsmAddress = selectedPicInfos.maxMemPos;
                picMem[0] = 0x02; //LJMP
                picMem[1] = (byte)((gotoAsmAddress >> 8) & 0xFF);
                picMem[2] = (byte)(gotoAsmAddress & 0xFF);
            }

            // MSP430
            // write block size variable
            if (selectedPicInfos.family == "4")
            {
                int extendedAddress = 0;

                selectedPicInfos.dividerHexToMemory = 1; // with Msp family physical address = hex address
                selectedPicInfos.maxMemPos = selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize + 8; //in bytes not word (+8 bytes is for jump to program start address)
                selectedPicInfos.minMemPos = selectedPicInfos.flashMem - selectedPicInfos.flashMem_Msp;
                // MOV.W #RESET,PC
                picMem[extendedAddress + 0 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize_Msp] = 0x30;
                picMem[extendedAddress + 1 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize_Msp] = 0x40;
                picMem[extendedAddress + 2 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize_Msp] = picMem[0xFFFE];
                picMem[extendedAddress + 3 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize_Msp] = picMem[0xFFFF];
                picMem[extendedAddress + 4 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize_Msp] = 0xFF;
                picMem[extendedAddress + 5 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize_Msp] = 0xFF;
                picMem[extendedAddress + 6 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize_Msp] = 0xFF;
                picMem[extendedAddress + 7 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize_Msp] = 0xFF;

                // GOTO to bootloader location (Information Memory Segment D)
                gotoAsmAddress = selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize_Msp + 8;
                picMem[0xFFFE] = (byte)(gotoAsmAddress & 0xFF);
                picMem[0xFFFF] = (byte)((gotoAsmAddress >> 8) & 0xFF);
            }

            // NXP
            // write block size variable
            if (selectedPicInfos.family == "3")
            {
                int extendedAddress = 0;
                int csum_ll = 0;
                int csum_lh = 0;
                int csum_hl = 0;
                int csum_hh = 0;

                selectedPicInfos.dividerHexToMemory = 1; // with Lpc family physical address = hex address
                selectedPicInfos.maxMemPos = selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize + 8; //in bytes not word (maxpos=max_flash-100+4) (+8 bytes is for jump to program start address)
                selectedPicInfos.minMemPos = 0;

                picMem[extendedAddress + 0 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMem[4];
                picMem[extendedAddress + 1 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMem[5];
                picMem[extendedAddress + 2 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMem[6];
                picMem[extendedAddress + 3 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMem[7];
                picMem[extendedAddress + 4 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                picMem[extendedAddress + 5 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                picMem[extendedAddress + 6 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                picMem[extendedAddress + 7 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;

                // GOTO to bootloader location
                gotoAsmAddress = selectedPicInfos.maxMemPos + 1; //Thumb
                picMem[7] = (byte)((gotoAsmAddress >> 24) & 0xFF);
                picMem[6] = (byte)((gotoAsmAddress >> 16) & 0xFF);
                picMem[5] = (byte)((gotoAsmAddress >> 8) & 0xFF);
                picMem[4] = (byte)(gotoAsmAddress & 0xFF);

                // Check Sum
                csum_ll += (int)picMem[0] + (int)picMem[4] + (int)picMem[8] + (int)picMem[12] + (int)picMem[16] + (int)picMem[20] + (int)picMem[24];
                csum_lh += (int)picMem[1] + (int)picMem[5] + (int)picMem[9] + (int)picMem[13] + (int)picMem[17] + (int)picMem[21] + (int)picMem[25] + ((csum_ll >> 8) & 0xFF);
                csum_hl += (int)picMem[2] + (int)picMem[6] + (int)picMem[10] + (int)picMem[14] + (int)picMem[18] + (int)picMem[22] + (int)picMem[26] + ((csum_lh >> 8) & 0xFF);
                csum_hh += (int)picMem[3] + (int)picMem[7] + (int)picMem[11] + (int)picMem[15] + (int)picMem[19] + (int)picMem[23] + (int)picMem[27] + ((csum_hl >> 8) & 0xFF);

                picMem[31] = (byte)(255 - (csum_hh & 0xFF));
                picMem[30] = (byte)(255 - (csum_hl & 0xFF));
                picMem[29] = (byte)(255 - (csum_lh & 0xFF));
                picMem[28] = (byte)(256 - (csum_ll & 0xFF));
            }

            // AVR
            // write block size variable
            if (String.Compare(selectedPicInfos.family, "3") < 0)
            {
                int opecode;
                int operand;
                int j_address;
                int jp_hh;
                int jp_hl;
                int jp_lh;
                int jp_ll;

                int extendedAddress = 0;

                selectedPicInfos.dividerHexToMemory = 2; // with tinyAVR family physical address = hex address / 2
                selectedPicInfos.maxMemPos = selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize + 8; //in bytes not word (maxpos=max_flash-100+4) (+8 bytes is for jump to program start address)
                selectedPicInfos.minMemPos = 0;

                operand = picMem[extendedAddress + 1 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize];
                opecode = (operand & 0xF0);
                if (opecode == 0xC0)//RJMP
                {
                    j_address = ((operand & 0x0F) << 8) + (int)picMem[extendedAddress + 0 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] + 1;
                    jp_hh = ((j_address >> 12) & 0x0F);
                    jp_hl = ((j_address >> 8) & 0x0F);
                    jp_lh = ((j_address >> 4) & 0x0F);
                    jp_ll = (j_address & 0x0F);
                    //0x019C:LDI zl,low(user_program)
                    picMem[extendedAddress + 0 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = (byte)(0xE0 | jp_ll);
                    picMem[extendedAddress + 1 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = (byte)(0xE0 | jp_lh);
                    //0x019D:LDI zh,high(user_program)
                    picMem[extendedAddress + 2 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = (byte)(0xF0 | jp_hl);
                    picMem[extendedAddress + 3 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = (byte)(0xE0 | jp_hh);
                    //0x019E:IJMP
                    picMem[extendedAddress + 4 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0x09;
                    picMem[extendedAddress + 5 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0x94;
                    picMem[extendedAddress + 6 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                    picMem[extendedAddress + 7 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                }
                if (opecode == 0xD0)//RCALL
                {
                    j_address = ((operand & 0x0F) << 8) + (int)picMem[extendedAddress + 0 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] + 1;
                    jp_hh = ((j_address >> 12) & 0x0F);
                    jp_hl = ((j_address >> 8) & 0x0F);
                    jp_lh = ((j_address >> 4) & 0x0F);
                    jp_ll = (j_address & 0x0F);
                    picMem[extendedAddress + 0 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = (byte)(0xE0 | jp_ll);
                    picMem[extendedAddress + 1 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = (byte)(0xE0 | jp_lh);
                    //0x019D:LDI zh,high(user_program)
                    picMem[extendedAddress + 2 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = (byte)(0xF0 | jp_hl);
                    picMem[extendedAddress + 3 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = (byte)(0xE0 | jp_hh);
                    //0x019E:ICALL
                    picMem[extendedAddress + 4 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0x09;
                    picMem[extendedAddress + 5 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0x95;
                    //0x019F:.DW 0xC061	;RJMP 0x0001
                    j_address = ((selectedPicInfos.bootloaderSize - 8) / 2) + 1;
                    picMem[extendedAddress + 6 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = (byte)j_address;
                    picMem[extendedAddress + 7 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xC0;
                }
                if (!(opecode == 0xC0) && !(opecode == 0xD0))
                {
                    //0x019D:.DW 0xC063	;RJMP 0x0001
                    j_address = ((selectedPicInfos.bootloaderSize - 8) / 2) + 3;
                    picMem[extendedAddress + 2 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = (byte)j_address;
                    picMem[extendedAddress + 3 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xC0;
                    picMem[extendedAddress + 4 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                    picMem[extendedAddress + 5 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                    picMem[extendedAddress + 6 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                    picMem[extendedAddress + 7 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                }

                // GOTO to bootloader location
                //ATTINY13A   .dw 0xcf9f (RJMP PC-0x60)
                //picMem[0] = 0x9f;
                //picMem[1] = 0xcf;
                gotoAsmAddress = 0xCFFF - (selectedPicInfos.bootloaderSize - 8) / 2;
                picMem[1] = (byte)((gotoAsmAddress >> 8) & 0xFF);
                picMem[0] = (byte)(gotoAsmAddress & 0xFF);
            }

            // 8bits PIC family
            // For the 16F8XX family the write block size is 8 bytes long 
            //   (for PIC16F88x, 2k or 4k devices = 4 words, but for 8k it's 8 words ?)
            //   (for PIC16F87xA it's 4 words = 8 bytes : OK !)
            //    erasing block size = 16 words for PIC16F88x
            //    erasing block size = 4 words for PIC16F87xA
            // The PIC16F87 and PIC16F88 the write block size must be 64 bytes long
            // The PIC10F320 and PIC10F322 the write block size must be 32 bytes long
            // The PIC12F1840 the write block size must be 64 bytes long
            if (selectedPicInfos.family == "B")
            {
                selectedPicInfos.dividerHexToMemory = 2; // with PIC16 family physical address = hex address / 2
                //block=4  #PIC Block 4 instructions (8 memory positions)
                selectedPicInfos.maxMemPos = selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize + 8; //in bytes not word (maxpos=max_flash-100+4) (+8 bytes is for jump to program start address)
                selectedPicInfos.minMemPos = 0;

                // searching initializaded pcLath
                int k = 0;
                int pcLath = 0;
                bool gotoFound = false;
                byte[] picMemFixed = new byte[8];
                int code = 0;

                // preparation for GOTO to program start
                for (int i = 0; i < 8; i += 2)
                {
                    if (picMem[i] != 0xFF)
                    {
                        picMemFixed[k] = picMem[i];
                        picMemFixed[k + 1] = picMem[i + 1];

                        code = (picMem[i + 1] << 8) + picMem[i];

                        if ((code & 0x3800) == 0x2800) // looking for a goto somewhere
                            gotoFound = true;
                        else if (code == 0x018A) // looking clrf pclath
                            pcLath = 2;
                        else if (code == 0x118A) // looking for bcf pclath,3
                            pcLath = pcLath + 1;
                        else if (code == 0x120A) // looking for bcf pclath,4
                            pcLath = pcLath + 1;
                        else if (code == 0x008A) // looking for movwf pclath
                            pcLath = 2;

                        k = k + 2;
                    }
                }
                if (!gotoFound)
                {
                    textMessages.AppendText("   WARNING: GOTO not found in first 4 words!\r\n");
                    textMessages.AppendText("      If using a compiler, maybe you should write\r\n");
                    textMessages.AppendText("      some directive to enable the use of bootloaders,\r\n");
                    textMessages.AppendText("      or maybe you could fix it by adding an interrupt\r\n");
                    textMessages.AppendText("      handler to your program.\r\n");
                }
                if (pcLath != 2)
                {
                    textMessages.AppendText("   WARNING: pclath not fully initialised before GOTO! ... \r\n");

                    if ((k > 6) || (k == 0)) // no pclath directive detected in 4 first words of code
                    {
                        textMessages.AppendText("   WARNING: first 4 words of code could not be fixed\r\n");
                        textMessages.AppendText("      Maybe you should use some directive in your compiler\r\n");
                        textMessages.AppendText("      to enable the use of bootloaders\r\n");
                    }
                    else
                    {
                        // transfer fixes bytes just before bootloader code
                        picMem[0 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0x8A;
                        picMem[1 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0x01;

                        if (picMemFixed[0] != 0xFF)
                        {
                            picMem[2 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMemFixed[0];
                            picMem[3 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMemFixed[1];
                        }
                        if (picMemFixed[2] != 0xFF)
                        {
                            picMem[4 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMemFixed[2];
                            picMem[5 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMemFixed[3];
                        }
                        if (picMemFixed[4] != 0xFF)
                        {
                            picMem[6 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMemFixed[4];
                            picMem[7 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMemFixed[5];
                        }
                        textMessages.AppendText("   Code successfully repaired.\r\n");
                    }
                }
                // GOTO to bootloader location
                // adding movlw page_address
                //(page of the end of the flash memory)
                picMem[0] = (byte)((selectedPicInfos.maxMemPos / 2) >> 8);
                picMem[1] = 0x30;
                // adding  movwf pclath 
                picMem[2] = 0x8A;
                picMem[3] = 0x00;
                // adding goto (2k words - selectedPicInfos.bootloaderSize/2 + 4) words
                // goto k -> 10 1kkk kkkk kkkk 
                if ((selectedPicInfos.flashMem / 2) < 2048)
                    gotoAsmAddress = 0x2800 + selectedPicInfos.maxMemPos / 2;
                else
                    gotoAsmAddress = 0x2800 + 2048 - selectedPicInfos.bootloaderSize / 2 + 4;
                picMem[5] = (byte)((gotoAsmAddress >> 8) & 0xFF);
                picMem[4] = (byte)(gotoAsmAddress & 0xFF);
            }

            // PIC18F family
            // The blocks have to be written using a 32 words (64 bytes) boundary 
            // so the first 8 bytes (reserved by TinyPic) will be re written
            // So we have to include a goto max_flash-bootloader_size+8 (=4 words)
            if ((selectedPicInfos.family == "C") || (selectedPicInfos.family == "J"))
            {
                // point to bootLoader start address (in word, not byte, because it's a goto in asm)
                gotoAsmAddress = ((selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize + 8) / 2);
                hhGotoAsmAddress = (byte)((gotoAsmAddress >> 16) & 0x0F);
                hGotoAsmAddress = (byte)((gotoAsmAddress >> 8) & 0xFF);
                lGotoAsmAddress = (byte)(gotoAsmAddress & 0xFF);

                picMem[0] = lGotoAsmAddress;
                picMem[1] = 0xEF;
                picMem[2] = hGotoAsmAddress;
                picMem[3] = (byte)(0xF0 + hhGotoAsmAddress);
                selectedPicInfos.dividerHexToMemory = 1;
                selectedPicInfos.maxMemPos = selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize + 8;
                selectedPicInfos.minMemPos = 0;
            }

            // 16bit PIC D E family
            if ((selectedPicInfos.family == "D") || (selectedPicInfos.family == "E"))
            {
                // The blocks have to be written using a 32 words (128 bytes) boundary 
                // so the first 8 bytes(Reset Vector) (reserved by TinyPic) will be re written
                // So we have to include a goto max_flash-bootloader_size+16 (=4 words)

                int extendedAddress = 0;
                picMem[extendedAddress + 0 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMem[0];
                picMem[extendedAddress + 1 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMem[1];
                picMem[extendedAddress + 2 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMem[2];
                picMem[extendedAddress + 3 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMem[3];
                picMem[extendedAddress + 4 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMem[4];
                picMem[extendedAddress + 5 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMem[5];
                picMem[extendedAddress + 6 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMem[6];
                picMem[extendedAddress + 7 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = picMem[7];
                picMem[extendedAddress + 8 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                picMem[extendedAddress + 9 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                picMem[extendedAddress + 10 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                picMem[extendedAddress + 11 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                picMem[extendedAddress + 12 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                picMem[extendedAddress + 13 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                picMem[extendedAddress + 14 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;
                picMem[extendedAddress + 15 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize] = 0xFF;

                // point to bootLoader start address (in word, not byte, because it's a goto in asm)
                gotoAsmAddress = (selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize + 4 * 4) / 2;

                hhGotoAsmAddress = (byte)((gotoAsmAddress >> 16) & 0x0F);
                hGotoAsmAddress = (byte)((gotoAsmAddress >> 8) & 0xFF);
                lGotoAsmAddress = (byte)(gotoAsmAddress & 0xFF);

                picMem[0] = lGotoAsmAddress;
                picMem[1] = hGotoAsmAddress;
                picMem[2] = 0x04;
                picMem[3] = 0x00;
                picMem[4] = hhGotoAsmAddress;
                picMem[5] = 0x00;
                picMem[6] = 0x00;
                picMem[7] = 0x00;
                selectedPicInfos.dividerHexToMemory = 2;
                selectedPicInfos.maxMemPos = selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize + 4 * 4;
                selectedPicInfos.minMemPos = 0;
            }

            // PIC32MX family
            // ---> from Microchip PIC32MX Flash Programming Specification
            // INHX32 file format
            // - BB – is a two-digit hexadecimal byte count representing the number of data bytes that appear
            //   on the line. Divide this number by two to get the number of words per line.
            // - AAAA – is a four-digit hexadecimal address representing the starting address of the data
            //   record. Format is high byte first followed by low byte. The address is doubled because this format
            //   only supports 8 bits. Divide the value by two to find the real device address.
            // - TT – is a two-digit record type that will be '00' for data records, '01' for end-of-file records 
            //   and '04' for extended-address record.
            // - HHHH – is a four-digit hexadecimal data word. Format is low byte followed by high byte. There
            //   will be BB/2 data words following TT.
            if (selectedPicInfos.family == "F")
            {
                selectedPicInfos.dividerHexToMemory = 1;
                selectedPicInfos.maxMemPos = selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize;
                selectedPicInfos.minMemPos = 0;
            }

            if (checkShowTransfert.Checked)
            {
                if ((selectedPicInfos.family == "D") || (selectedPicInfos.family == "E"))
                    textMessages.AppendText("   minMemPos=" + selectedPicInfos.minMemPos.ToString("X8") + ", maxMemPos=" + selectedPicInfos.maxMemPos.ToString("X8") + ", blockSize=" + (selectedPicInfos.blockSize / 4 * 3).ToString() + "\r\n");
                else if (selectedPicInfos.family == "4")
                    textMessages.AppendText("   minMemPos=" + selectedPicInfos.minMemPos.ToString("X8") + ", maxMemPos=" + (selectedPicInfos.maxMemPos - selectedPicInfos.bootloaderSize_Msp + 8).ToString("X8") + ", blockSize=" + selectedPicInfos.blockSize.ToString() + "\r\n");
                else
                    textMessages.AppendText("   minMemPos=" + selectedPicInfos.minMemPos.ToString("X8") + ", maxMemPos=" + selectedPicInfos.maxMemPos.ToString("X8") + ", blockSize=" + selectedPicInfos.blockSize.ToString() + "\r\n");
            }
            if ((checkShowTransfert.Checked) && ((selectedPicInfos.family == "D") || (selectedPicInfos.family == "E")))
            {
                textMessages.AppendText("   first 4 words at address 0x" + ((selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize) / selectedPicInfos.dividerHexToMemory).ToString("X4") + ": \r\n");
                for (int i = 0; i < 16; i += 4)
                    textMessages.AppendText("      0x" + picMem[i + 2 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize].ToString("X2") + picMem[i + 1 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize].ToString("X2") + picMem[i + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize].ToString("X2") + "\r\n");
            }
            if ((checkShowTransfert.Checked) && (selectedPicInfos.family != "F") && (selectedPicInfos.family != "D") && (selectedPicInfos.family != "E") && (selectedPicInfos.family != "4"))
            {
                textMessages.AppendText("   first 4 words at address 0x" + ((selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize) / selectedPicInfos.dividerHexToMemory).ToString("X4") + ": \r\n");
                for (int i = 0; i < 8; i += 2)
                    textMessages.AppendText("      0x" + picMem[i + 1 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize].ToString("X2") + picMem[i + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize].ToString("X2") + "\r\n");
            }
            if ((checkShowTransfert.Checked) && (selectedPicInfos.family == "4"))
            {
                textMessages.AppendText("   first 4 words at address 0x" + ((selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize_Msp) / selectedPicInfos.dividerHexToMemory).ToString("X4") + ": \r\n");
                for (int i = 0; i < 8; i += 2)
                    textMessages.AppendText("      0x" + picMem[i + 1 + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize_Msp].ToString("X2") + picMem[i + selectedPicInfos.flashMem - selectedPicInfos.bootloaderSize_Msp].ToString("X2") + "\r\n");
            }

            return true;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: eraseFlash
        // Parameters: none
        // Return: true, if erase OK ; false, if problem during erase
        // Description: for 'A' (8bits PIC extended) and 'F' (PIC32MX3to7) families.
        //              erase flash memory before write, because writing data on a non erased address
        //              will write a random value (if writed data is different from the stored one, if 
        //              it's the same then write is OK).
        //              WARNING: erase procedural is different if write Configuration Bytes
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private bool eraseFlash()
        {
            byte[] command = new byte[1];
            byte nbPages;
            byte erasedPages = 0;
            byte answer;

            if ((checkWriteConfig.Checked) && (isConfig == true))
                command[0] = 0x43; // 0x43 = 'C' for Config
            else
                command[0] = 0x45; // 0x45 = 'E' for Erase

            serialPort.Write(command, 0, 1);
            textRawTransfert.AppendText("\r\nsend: " + command[0].ToString());
            try
            {
                nbPages = (byte)serialPort.ReadByte(); // nb pages to be erased given by the PIC32
                textRawTransfert.AppendText("\r\nreceive: " + nbPages.ToString("X2") + ", ");

                while ((answer = (byte)serialPort.ReadByte()) != 0x4B) // 0x4B = 'K', erase completed ; 0x45 = 'E', page erased
                {
                    textRawTransfert.AppendText(answer.ToString("X2") + ", ");

                    erasedPages++;
                    if (erasedPages > nbPages)
                        return false;

                    if (aborted)
                        return false;

                    progressBar.Increment(progressBar.Maximum / (nbPages - 1));
                }

                textRawTransfert.AppendText(answer.ToString("X2") + ", ");

                textMessages.AppendText("   Erase OK\r\n");
                progressBar.Value = 0;
                return true;
            }
            catch
            {
                textMessages.AppendText(" Erasing no answer\r\n");
                return false;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: checkHex
        // Parameters: string[] lines = all the lines from "hex" file
        // Return: true, if hex file is a program dedied to connected PIC's family 
        // Description: if hex file was made for the connected device then return "true", else return "false" 
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private bool checkHex(string[] lines)
        {
            int total = 0; // total bytes
            string INHX = "INX8M"; // coding type 8 or 16 bits
            string picSeries = "PIC16F"; // PIC family the hex belongs
            string cfg = ""; // is there config in hex ?
            string eeprom = ""; // is there eeprom in hex ?
            int address = 0;
            int recordType = 0;
            int byteCount = 0; // nb of bytes in a line
            int chs = 0; // calculated checksum
            int crc = 0; // line's CRC
            int mask = 0; // checksum mask of hexfile
            int rowCounter = 0; // lines red
            bool needVerifyCfg = false; // for PIC32, true = check if next address >= 0x2FF0 (= config bytes) 

            if (String.Compare(selectedPicInfos.family, "A") >= 0)
            {
                if (checkShowCheckFile.Checked)
                    textMessages.AppendText("Checking hex file: \r\n");

                foreach (string line in lines)
                {
                    if (line.ToUpper().Contains(":00000001FF"))
                    {
                        if (checkShowCheckFile.Checked)
                            textMessages.AppendText("   Hex file end line\r\n");
                    }
                    else if (line.Substring(0, 1).Trim() != ":")
                    {
                        if (line.Substring(0, 1).Trim() == ";")
                        {
                            if (checkShowCheckFile.Checked)
                                textMessages.AppendText("   Comment in file: " + line + "\r\n");
                        }
                        else
                        {
                            textMessages.AppendText("Error: Hex file not recognized!!!\r\n");
                            return false;
                        }
                    }
                    else
                    {
                        if (line.ToUpper().Contains(":020000040000FA"))  // That is a type of the Intel hex format records (Extended Linear Address Record). It sets upper 16bits of the 32bit address.
                            total -= 2;

                        // Read Byte count
                        byteCount = Convert.ToInt32(line.Substring(1, 2).Trim(), 16); // convert bytes in line hexa string (":LL...") to decimal integer
                        total += byteCount;

                        // Read register address 
                        address = Convert.ToInt32(line.Substring(3, 4).Trim(), 16); // convert hexa address (":llAAAA...") to decimal
                        if ((address == 0x400E) && (picSeries == "PIC16F"))
                            cfg = " + cfg";
                        if ((address >= 0x4200) && (picSeries == "PIC16F"))
                            eeprom = " + eeprom";

                        // Read record type
                        recordType = Convert.ToInt32(line.Substring(7, 2).Trim(), 16); // convert record type hexa (":llaaaaTT...") to decimal

                        // Read Crc
                        crc = Convert.ToInt32(line.Substring(9 + 2 * byteCount, 2).Trim(), 16);

                        // Calculate checksum
                        chs = byteCount + Convert.ToInt32(line.Substring(3, 2).Trim(), 16) + Convert.ToInt32(line.Substring(5, 2).Trim(), 16) + recordType;

                        if (recordType == 0) // data
                        {
                            // verif if there are config bytes for PIC32
                            if ((address >= 0x2FF0) && needVerifyCfg)
                                cfg = " + cfg";
                            needVerifyCfg = false;

                            // Check pic series mask and file check sum
                            for (int i = 9; i < (9 + 2 * byteCount); i += 4)
                            {
                                // checksum for each line
                                chs += Convert.ToInt32(line.Substring(i, 2).Trim(), 16) + Convert.ToInt32(line.Substring(i + 2, 2).Trim(), 16);

                                // checksum mask of hexfile
                                mask = Convert.ToInt32(line.Substring(i, 4).Trim(), 16);
                                mask &= 0x00ff;

                                //                                if ((mask > 0x3f) && (picSeries != "PIC32"))
                                //                                    picSeries = "PIC18F";
                            }

                            // two's complement sum of the values of all fields
                            chs = (1 + ~chs) & 0xff;
                            // Check if chs calculated an check sum readed from file are the same      
                            if (chs != crc)
                                textMessages.AppendText("   Warning: CRC failed on line " + (rowCounter + 1).ToString() + "\r\n");
                        }
                        else if ((recordType == 2) && (INHX != "INX32M")) // extended segment address record
                        {
                            INHX = "INX16M";
                        }
                        else if ((recordType == 3) || (recordType == 4)) // extended linear address record
                        {
                            INHX = "INX32M";
                            //                            if (!line.ToUpper().Contains(":020000040000FA"))
                            //                                picSeries = "PIC18F";
                            // for PIC18F
                            if (line.ToUpper().Contains(":020000040030CA"))
                                cfg += " + cfg";
                            // for PIC18F
                            if (line.ToUpper().Contains(":020000040020DA"))
                                cfg += " + userID";
                            if (line.ToUpper().Contains(":0200000400F00A"))
                                eeprom = " + eeprom";
                            // for PIC32
                            if (line.ToUpper().Contains(":020000041D00DD")) // PIC32 program flash memory upper 16b address (=1D00)
                                picSeries = "PIC32";
                            if (line.ToUpper().Contains(":020000041FC01B"))
                            {
                                picSeries = "PIC32";
                                needVerifyCfg = true;
                            }
                        }

                        rowCounter++;
                    }
                }

                if (checkShowCheckFile.Checked)
                    textMessages.AppendText("   HEX sumary: " + INHX + ", \r\n               " + picSeries + cfg + eeprom + ", \r\n               total=" + total.ToString() + " bytes.\r\n");

                if (((picSeries == "PIC16F") && (selectedPicInfos.family == "B"))
                    || ((picSeries == "PIC18F") && ((selectedPicInfos.family == "C") || (selectedPicInfos.family == "J")))
                    || ((picSeries == "PIC32") && (selectedPicInfos.family == "F")))
                {
                    textMessages.AppendText("Hex file verified, OK\r\n");
                    return true;
                }
                else if ((picSeries == "PIC18F") && (selectedPicInfos.family == "B"))
                {
                    textMessages.AppendText("Warning: can't determine if hex file is for PIC18 or enhanced PIC16 device.\r\n");
                    return true;
                }
                else if ((selectedPicInfos.family == "D") || (selectedPicInfos.family == "E"))
                {
                    textMessages.AppendText("Warning: Hex files for PIC24, dsPIC30 and dsPIC33 not verified for the moment.\r\n");
                    return true;
                }
                else
                {
                    textMessages.AppendText("Error: Hex file for " + picSeries + ", PIC family mismatch.\r\n");
                    return false;
                }
            }
            else
            {
                textMessages.AppendText("Warning: AVR and NXP Hex files not verified for the moment.\r\n");
                return true;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: checkPIC
        // Parameters: int nbTries = nb of time we try to contact the PIC
        //             bool verbose = true, display some messages
        // Return: true, if a PIC answered to the check and if it's ID code is in "piccodes.ini"
        // Description: if a PIC has answered to PC and if it's ID code is in "piccodes.ini", then fill
        //              "selectedPicInfos" (by calling "getPicInfos" function) structure with elements in 
        //              contained in "piccodes.ini" and return 'true'.
        //              Else return 'false' (if there is no answer, bad answer or if ID code is not found)
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        bool checkPIC(int nbTries, bool verbose)
        {
            byte[] serBuffer;
            serBuffer = new byte[2];
            bool checkOK = false;
            bool answer = false;
            int i = 0;
            string family = "";

            if (verbose)
                textMessages.AppendText("Check Device...\r\n");

            // get reply from PIC
            while ((i < nbTries) && (!answer))
            {
                textRawTransfert.AppendText("\r\nCheck Device...");

                if (aborted)
                    break;

                i++;
                if (nbTries > 1)
                    progressBar.Increment(progressBar.Maximum / nbTries);

                //--- rem start
                // Hey! I know, this part of the code seems strange... 
                // but it's just to continue to check the COM if it was not allready opened
                // ### it can be also usefull if device is deconnected during soft reset?
                if ((!checkVirtualPIC.Checked) && (!serialPort.IsOpen))
                    openSerial(true);
                if ((checkVirtualPIC.Checked) || (serialPort.IsOpen))
                {
                    //--- rem stop
                        resetPICbySoft(verbose && ((checkShowAnswer.Checked) || (i == 1)));

                    // send "ask" to PIC
                    if (!checkVirtualPIC.Checked)
                    {
                        serBuffer[0] = 0xC1;
                        serialPort.DiscardInBuffer(); // from Dan (this line must be here, not after, for USB to RS232 transfers)
                        serialPort.Write(serBuffer, 0, 1);
                    }
                    textRawTransfert.AppendText("\r\nsend: C1");
                    try
                    {
                        if ((checkShowAnswer.Checked) && (verbose))
                            textMessages.AppendText("   Device answer: ");
                        // byte 1
                        if (!checkVirtualPIC.Checked)
                            serBuffer[0] = (byte)serialPort.ReadByte();
                        else
                            serBuffer[0] = Convert.ToByte(textVirtualPIC.Text, 16);
                        textRawTransfert.AppendText("\r\nreceive: " + serBuffer[0].ToString("X2") + ", ");

                        if ((checkShowAnswer.Checked) && (verbose))
                            textMessages.AppendText("0x" + serBuffer[0].ToString("X2"));
                        // byte 2 (if exists, else go to "catch" after ReadTimeOut exception)
                        if (!checkVirtualPIC.Checked)
                            serBuffer[1] = (byte)serialPort.ReadByte();
                        else
                            serBuffer[1] = (byte)Convert.ToInt32(Encoding.ASCII.GetBytes(textVirtualPICFam.Text.ToUpper())[0]);
                        textRawTransfert.AppendText(serBuffer[1].ToString("X2"));
                        if ((checkShowAnswer.Checked) && (verbose))
                            textMessages.AppendText(" 0x" + serBuffer[1].ToString("X2") + "='" + Char.ConvertFromUtf32(serBuffer[1]) + "'\r\n");

                        answer = true;

                        // if Family is not a digit or a upper case letter, then we've got a problem 
                        if ((serBuffer[1] < 0x30) || ((serBuffer[1] > 0x39) && (serBuffer[1] < 0x41)) || (serBuffer[1] > 0x5A))
                        {
                            if (verbose)
                                textMessages.AppendText("   Error: Wrong answer from Device!!!\r\n");
                        }
                        else
                        {
                            if (serBuffer[1] == 0x4B) // old firmware type, 'K' instead of 'family'
                            {
                                if (serBuffer[0] < 0x40)
                                    family = "B";
                                else if (serBuffer[0] < 0x70)
                                    family = "C";
                                else if (serBuffer[0] < 0xA0)
                                    family = "D";
                                else if (serBuffer[0] < 0xD0)
                                    family = "E";
                                else if (serBuffer[0] < 0xF0)
                                    family = "F";
                                else if (serBuffer[0] < 0xFA)
                                    family = "1";
                                else
                                    family = "2";
                            }
                            else // new firmware type
                                family = Char.ConvertFromUtf32(serBuffer[1]);
                            selectedPicInfos = getPicInfos(serBuffer[0], family);
                            if (selectedPicInfos.idCode != 0)
                            {
                                if ((checkShowAnswer.Checked) && (verbose))
                                {
                                    textMessages.AppendText("    byte OK, now check ID-code and Family...\r\n");
                                    textMessages.AppendText("      idCode = $" + selectedPicInfos.idCode.ToString("X2") + "\r\n");
                                    textMessages.AppendText("      family = " + selectedPicInfos.family + "\r\n");
                                    textMessages.AppendText("      description = " + selectedPicInfos.description + "\r\n");
                                    if (selectedPicInfos.family == "4")
                                        textMessages.AppendText("      flash mem = " + selectedPicInfos.flashMem_Msp.ToString() + " bytes\r\n");
                                    else
                                        textMessages.AppendText("      flash mem = " + selectedPicInfos.flashMem.ToString() + " bytes\r\n");
                                    if ((String.Compare(selectedPicInfos.family, "A") < 0) || (selectedPicInfos.family == "B"))
                                        textMessages.AppendText("      EEPROM mem = " + (selectedPicInfos.eepromMem / 2).ToString() + " bytes\r\n");
                                    else
                                        textMessages.AppendText("      EEPROM mem = " + selectedPicInfos.eepromMem.ToString() + " bytes\r\n");
                                    //$#21
                                    if ((selectedPicInfos.family == "D") || (selectedPicInfos.family == "E"))
                                        textMessages.AppendText("      Bootloader size = " + (selectedPicInfos.bootloaderSize * 3 / 4).ToString() + " bytes\r\n");
                                    else if (selectedPicInfos.family == "4")
                                        textMessages.AppendText("      Bootloader size = " + selectedPicInfos.bootloaderSize_Msp.ToString() + " bytes\r\n");
                                    else //$#21e
                                        textMessages.AppendText("      Bootloader size = " + selectedPicInfos.bootloaderSize.ToString() + " bytes\r\n");
                                    //$#22
                                    if ((selectedPicInfos.family == "D") || (selectedPicInfos.family == "E"))
                                        textMessages.AppendText("      Transfert block size = " + (selectedPicInfos.blockSize * 3 / 4).ToString() + " bytes\r\n");
                                    else
                                        //$#22e
                                        textMessages.AppendText("      Transfert block size = " + selectedPicInfos.blockSize.ToString() + " bytes\r\n");
                                }
                                if (verbose)
                                    textMessages.AppendText("   Found: " + selectedPicInfos.description + "\r\n");
                                checkOK = true;
                            }
                            else
                            {
                                if (verbose)
                                {
                                    textMessages.AppendText("   Error: unknown Device ID code and/or Family.\r\n");
                                    textMessages.AppendText("          Add your Device to \"piccodes.ini\" file\r\n");
                                }
                            }
                        }
                    }
                    catch
                    {
                        if ((checkShowAnswer.Checked) && (verbose))
                            textMessages.AppendText("   no answer...\r\n");
                        if (nbTries > 1)
                            System.Threading.Thread.Sleep(int.Parse(textDelayCheck.Text));
                    }
                }
                else
                    System.Threading.Thread.Sleep(int.Parse(textReadTimeOut.Text) + int.Parse(textDelayCheck.Text)); // wait some ms
            }

            if ((i == nbTries) && (verbose))
            {
                textMessages.AppendText("   Error: No Device Detected!!!\r\n");
                textMessages.AppendText("   Verify: - COM number\r\n");
                textMessages.AppendText("           - baud rate\r\n");
                textMessages.AppendText("           - if Device was reseted less than 1sec ago\r\n");
                textMessages.AppendText("             (do you need to check \"RST Reset\"?)\r\n");
                textMessages.AppendText("           - if TinyBootloader firmware is correctly\r\n");
                textMessages.AppendText("             programmed into Device\r\n");
            }

            if (nbTries > 1)
                progressBar.Value = 0;

            if (checkOK == true)
                writeSuccess = 1;
            else
                writeSuccess = 0;
            return checkOK;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: getPicInfos
        // Parameters: id = number given by the PIC during "check PIC"
        // Return: picInfos containing infos about the PIC read in "piccodes.ini" file
        // Description: read "piccodes.ini" file, and if ID code is found in it, return picInfos values
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private picInfos getPicInfos(byte id, string family)
        {
            StreamReader openedFileHandler;
            picInfos tempInfos = new picInfos();
            bool picMatched = false;
            string line;
            string[] infos;
            infos = new string[nbInfosPerLine];
            byte tempIdCode = 0;

            tempInfos.idCode = 0; // 0 = PIC not found in "piccodes.ini" file
            tempInfos.family = "";
            tempInfos.description = "";
            tempInfos.flashMem = 0;
            tempInfos.eepromMem = 0;
            tempInfos.startPosEEPROM = 0;

            // if "piccodes.ini" file exists open it to grab detected PIC infos
            if (File.Exists(piccodesIniFile))
            {
                openedFileHandler = File.OpenText(piccodesIniFile);

                line = openedFileHandler.ReadLine();
                while ((line != null) && (!picMatched))
                {
                    infos = splitPicCodesLine(line);

                    // get device's code in line red from "piccodes.ini" file
                    if (infos[0] != null)
                    {
                        if (infos[0].StartsWith("$"))
                        {
                            infos[0] = infos[0].Substring(1); // remove '$'
                            tempIdCode = Convert.ToByte(infos[0], 16); // convert hexa string to decimal integer
                        }
                        else
                            tempIdCode = byte.Parse(infos[0]);

                        infos[1] = infos[1].ToUpper();
                    }

                    // compare device's code in line red from "piccodes.ini" file to device's code given by the PIC
                    if ((tempIdCode == id) && (family == infos[1])) // we found infos for the PIC connected to the PC
                    {
                        // device's ID code 
                        tempInfos.idCode = id;
                        // device's family
                        tempInfos.family = infos[1];
                        // device's description string
                        tempInfos.description = infos[2];
                        // device's flash memory (in bytes)
                        if (infos[3].StartsWith("$"))
                        {
                            infos[3] = infos[3].Substring(1); // remove '$'
                            tempInfos.flashMem = Convert.ToInt32(infos[3], 16); // convert hexa string to decimal integer
                        }
                        else
                            tempInfos.flashMem = int.Parse(infos[3]);
                        // device's EEPROM memory (in bytes)
                        if (infos[4].StartsWith("$"))
                        {
                            infos[4] = infos[4].Substring(1); // remove '$'
                            tempInfos.eepromMem = Convert.ToInt32(infos[4], 16); // convert hexa string to decimal integer
                        }
                        else
                            tempInfos.eepromMem = int.Parse(infos[4]);
                        if (String.Compare(tempInfos.family, "A") < 0)
                            tempInfos.eepromMem *= 2; // for AVR devices EEPROM addressing is in words and not bytes
                        if (tempInfos.family == "B")
                            tempInfos.eepromMem *= 2; // for "B" family EEPROM addressing is in words and not bytes
                        // device's family bootloader size (in bytes)
                        if (infos[5].ToLower() == "default")
                        {
                            // verify family
                            if (tempInfos.family == "B")
                                tempInfos.bootloaderSize = familyPicB_DefaultBootloaderSize;
                            if (tempInfos.family == "C")
                                tempInfos.bootloaderSize = familyPicC_DefaultBootloaderSize;
                            if (tempInfos.family == "D")
                                tempInfos.bootloaderSize = familyPicD_DefaultBootloaderSize;
                            if (tempInfos.family == "E")
                                tempInfos.bootloaderSize = familyPicE_DefaultBootloaderSize;
                            if (tempInfos.family == "J")
                                tempInfos.bootloaderSize = familyPicJ_DefaultBootloaderSize;
                            if (tempInfos.family == "F")
                                tempInfos.bootloaderSize = familyPicF_DefaultBootloaderSize;
                            if (tempInfos.family == "1")
                                tempInfos.bootloaderSize = familyAvr1_DefaultBootloaderSize;
                            if (tempInfos.family == "2")
                                tempInfos.bootloaderSize = familyAvr2_DefaultBootloaderSize;
                            if (tempInfos.family == "3")
                                tempInfos.bootloaderSize = familyLpc3_DefaultBootloaderSize;
                            if (tempInfos.family == "4")
                                tempInfos.bootloaderSize = familyMsp4_DefaultBootloaderSize;
                            if (tempInfos.family == "5")
                                tempInfos.bootloaderSize = familyC8051_DefaultBootloaderSize;
                        }
                        else
                            if (infos[5].StartsWith("$"))
                            {
                                infos[5] = infos[5].Substring(1); // remove '$'
                                tempInfos.bootloaderSize = Convert.ToInt32(infos[5], 16); // convert hexa string to decimal integer
                            }
                            else
                                tempInfos.bootloaderSize = int.Parse(infos[5]);
                        // device's family transfert block size (in bytes)
                        if (infos[6].ToLower() == "default")
                        {
                            // verify family
                            if (tempInfos.family == "B")
                                tempInfos.blockSize = familyPicB_DefaultBlockSize;
                            if (tempInfos.family == "C")
                                tempInfos.blockSize = familyPicC_DefaultBlockSize;
                            if (tempInfos.family == "D")
                                tempInfos.blockSize = familyPicD_DefaultBlockSize;
                            if (tempInfos.family == "E")
                                tempInfos.blockSize = familyPicE_DefaultBlockSize;
                            if (tempInfos.family == "J")
                                tempInfos.blockSize = familyPicJ_DefaultBlockSize;
                            if (tempInfos.family == "F")
                                tempInfos.blockSize = familyPicF_DefaultBlockSize;
                            if (tempInfos.family == "1")
                                tempInfos.blockSize = familyAvr1_DefaultBlockSize;
                            if (tempInfos.family == "2")
                                tempInfos.blockSize = familyAvr2_DefaultBlockSize;
                            if (tempInfos.family == "3")
                                tempInfos.blockSize = familyLpc3_DefaultBlockSize;
                            if (tempInfos.family == "4")
                                tempInfos.blockSize = familyMsp4_DefaultBlockSize;
                            if (tempInfos.family == "5")
                                tempInfos.blockSize = familyC8051_DefaultBlockSize;
                        }
                        else
                            if (infos[6].StartsWith("$"))
                            {
                                infos[6] = infos[6].Substring(1); // remove '$'
                                tempInfos.blockSize = Convert.ToInt32(infos[6], 16); // convert hexa string to decimal integer
                            }
                            else
                                tempInfos.blockSize = int.Parse(infos[6]);
                        picMatched = true;
                    }
                    line = openedFileHandler.ReadLine();
                    if (tempInfos.family == "4")  // MSP430 family
                    {
                        tempInfos.flashMem_Msp = tempInfos.flashMem;
                        tempInfos.bootloaderSize_Msp = tempInfos.bootloaderSize;
                        tempInfos.flashMem = 0x10000;
                        tempInfos.bootloaderSize = 8;
                    }
                    if ((tempInfos.family == "D") || (tempInfos.family == "E"))  // 16bit PIC D E family
                    {
                        tempInfos.bootloaderSize = tempInfos.bootloaderSize / 3 * 4;
                        tempInfos.blockSize = tempInfos.blockSize / 3 * 4;
                    }
                }

                // when all is done, close config file
                openedFileHandler.Close();
            }
            else
                textMessages.AppendText("Error: Can't locate \"Piccodes.ini\" file!!!\r\n");

            return tempInfos;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: splitPicCodesLine
        // Parameters: line = line from "piccodes.ini" files to split
        // Return: splited parts of 'line'
        // Description: if 'line' begins with a ';' then it is a comment and the line is discarded,
        //              else the line is splitted into strings between ',' symbols
        //              The first is 'ID code', then 'description', a letter wich gives the PIC's family,
        //              the flash memory and finally the eeprom memory
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private string[] splitPicCodesLine(string line)
        {
            string[] infos;
            infos = new string[nbInfosPerLine];
            string[] stringSeparators = new string[] { "," };

            line = line.Trim(); // clear space before and after the text
            if (line.Length > 0) // if it remains something
            {
                if (!line.StartsWith(";"))
                {
                    infos = line.Split(stringSeparators, StringSplitOptions.RemoveEmptyEntries);
                    for (int i = 0; i < nbInfosPerLine; i++)
                        infos[i] = infos[i].Trim(); // remove spaces
                }
            }

            return infos;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: sendRemoteMessage
        // Parameters: verbose
        // Return: none
        // Description: send the string defined in "Remote Message:" to the device.
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void sendRemoteMessage(bool verbose)
        {
            System.Text.ASCIIEncoding encoding = new System.Text.ASCIIEncoding();
            byte[] chartosend;
            string[] asciicodes;

            if ((serialPort.IsOpen == true)||(checkVirtualPIC.Checked))
            {
                if (textRemoteMessage.Text.Length > 0)
                {
                    try
                    {
                        asciicodes = textRemoteMessage.Text.Split(default(string[]), StringSplitOptions.RemoveEmptyEntries);
                        chartosend = new byte[asciicodes.Length];
                        for (int i = 0; i < asciicodes.Length; i++)
                            chartosend[i] = byte.Parse(asciicodes[i]);
                        if (verbose)
                        {
                            textMessages.AppendText("   ... sending \"");
                            textMessages.AppendText(System.Text.ASCIIEncoding.ASCII.GetString(chartosend));
                            textMessages.AppendText("\"(as characters) or \"");
                            for (int i = 0; i < chartosend.Length; i++)
                                textMessages.AppendText(chartosend[i].ToString() + " ");
                            textMessages.AppendText("\"(as decimal) to the device \r\n");
                        }
                        // send data to serial port
                        if (!checkVirtualPIC.Checked)
                            serialPort.Write(chartosend, 0, chartosend.Length);
                        textRawTransfert.AppendText("\r\nsend: ");
                        for (int i = 0; i < chartosend.Length; i++)
                            textRawTransfert.AppendText(chartosend[i].ToString() + "(decimal), ");
                    }
                    catch (Exception e)
                    {
                        if (verbose)
                            textMessages.AppendText("[system->]" + e.Message + "[<-system]\r\n");
                    }
                }
                else
                    textMessages.AppendText("   ... no Remote Message defined, can't do this kind of reset!\r\n");
            }
        }
       
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: resetPICbySoft
        // Parameters: verbose
        // Return: none
        // Description: * if "RTS" Reset, do a PIC reset by the mean of COM's RTS pin
        //                (RTS pin must be connected to PIC's !MCLR pin, then no manual Reset needed) 
        //              * if "DTR" Reset, do a PIC reset by the mean of COM's DTR pin
        //                (DTR pin must be connected to PIC's !MCLR pin, then no manual Reset needed) 
        //              * if "Remote Signal" Reset checked, send the string defined in "Remote Message:" to the
        //                device so it receives it and reboots.
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void resetPICbySoft(bool verbose)
        {
            // RTS Reset
            if (radioResetRTS.Checked && radioResetRTS.Enabled)
            {
                if (verbose)
                    textMessages.AppendText("   Hardware RTS reseting Device\r\n");

                if (!checkVirtualPIC.Checked)
                {
                    serialPort.RtsEnable = true;
                    System.Threading.Thread.Sleep(int.Parse(textRTSTrue.Text)); // wait some ms
                    serialPort.RtsEnable = false;
                    System.Threading.Thread.Sleep(int.Parse(textRTSFalse.Text)); // wait some ms 
                }
            }

            // DTR Reset
            if (radioResetDTR.Checked && radioResetDTR.Enabled)
            {
                if (verbose)
                    textMessages.AppendText("   Hardware DTS reseting Device\r\n");

                if (!checkVirtualPIC.Checked)
                {
                    serialPort.DtrEnable = true;
                    System.Threading.Thread.Sleep(int.Parse(textRTSTrue.Text)); // wait some ms
                    serialPort.DtrEnable = false;
                    System.Threading.Thread.Sleep(int.Parse(textRTSFalse.Text)); // wait some ms 
                }
            }

            // Remote Signal Reset
            if (radioResetRemoteSignal.Checked && radioResetRemoteSignal.Enabled)
            {
                if (verbose)
                    textMessages.AppendText("   Software Remote Signal reseting Device\r\n");
                sendRemoteMessage(verbose);
                if (!checkVirtualPIC.Checked)
                        System.Threading.Thread.Sleep(int.Parse(textRemoteWait.Text));
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: buttonSearch_Click
        // Parameters: windows stuff
        // Return: none
        // Description: if "Search COM" button pushed launch "searchCOM" function
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void buttonSearch_Click(object sender, EventArgs e)
        {
            searchCOM();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: searchCOM
        // Parameters: none
        // Return: none
        // Description: display all usable COM, attached to the PC, in "Detected COM:" listBox
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void searchCOM()
        {
            string[] ports = SerialPort.GetPortNames();

            // clear list box
            listDetectedCOM.Items.Clear();

            // then display each port name to the list box.
            foreach (string port in ports)
            {
                listDetectedCOM.Items.Add(port);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: listDetectedCOM_SelectedIndexChanged
        // Parameters: windows stuff
        // Return: none
        // Description: put selected COM name in "Selected COM:" textBox. THIS TEXT IS USED TO OPEN COM
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void listDetectedCOM_SelectedIndexChanged(object sender, EventArgs e)
        {
            selectedCOM.Text = (string)listDetectedCOM.SelectedItem;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: buttonCheck_Click
        // Parameters: windows stuff
        // Return: none
        // Description: check if there is a PIC with TinyBootloader firmware connected to selected COM
        //              using selected baud rate
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void buttonCheck_Click(object sender, EventArgs e)
        {
            Thread tt = new Thread(new ThreadStart(launchCheckPIC));
            aborted = false;
            tt.Start();
        }
        private void launchCheckPIC()
        {
            checkPIC(int.Parse(textNbChecks.Text), true);
            closeSerial(true);
            textMessages.AppendText("\r\n---------------------------------------------------------\r\n\r\n");
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: Form1_Load
        // Parameters: windows stuff
        // Return: none
        // Description: configure program at startup :
        //               - search all com and display them
        //               - if "config.ini" file exists the open it to configure program as it was last time
        //                 else configure by default
        //               - configure all checks, comboBox, text messages, etc as needed
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void Form1_Load(object sender, EventArgs e)
        {
            int selectedFirmwareBrandIndex = -1;   // -1 = nothing shown in the comboBox
            int selectedFirmwareDeviceIndex = -1;  // -1 = nothing shown in the comboBox
            int selectedFirmwareFlavourIndex = -1; // -1 = nothing shown in the comboBox
            bool isAtLeastV0_11_0_ConfigFile = false;

            // stange code, but if "debug" tab hasn't been displayed once then "Serial Transfert: RAW Display"
            // won't display anything
            tabControl.SelectedIndex = 1;
            tabControl.SelectedIndex = 0;

            // look at the connected COM
            searchCOM();

            configIniFile = Application.StartupPath + "/config.ini";

            // define default config
            piccodesIniFile = Application.StartupPath + "/piccodes.ini";
            textPiccodesPath.Text = piccodesIniFile;
            comboBaudSelect.SelectedIndex = 1;
            //DM-> avoid crash at startup if there is no COM port on the PC
            if (listDetectedCOM.Items.Count > 0)
            {
                listDetectedCOM.SelectedIndex = 0;
            } // ->DM
            selectedCOM.Text = (string)listDetectedCOM.SelectedItem;

            // if config file exists open it to configure application (will overwrite default parameters)
            if (File.Exists(configIniFile))
            {
                StreamReader openedFileHandler;
                openedFileHandler = File.OpenText(configIniFile);

                // COM config
                int baudrate_index = int.Parse(openedFileHandler.ReadLine());
                selectedCOM.Text = openedFileHandler.ReadLine();
                // Configuration tab: use of RTS
                radioResetRTS.Checked = bool.Parse(openedFileHandler.ReadLine());
                // check file before program PIC
                checkFile.Checked = bool.Parse(openedFileHandler.ReadLine());
                // flash prog write
                checkWriteFlashProg.Checked = bool.Parse(openedFileHandler.ReadLine());
                // EEPROM write
                checkWriteEEPROM.Checked = bool.Parse(openedFileHandler.ReadLine());
                // Configuration tab: COM parameters
                textReadTimeOut.Text = openedFileHandler.ReadLine();
                textDelayCheck.Text = openedFileHandler.ReadLine();
                textNbChecks.Text = openedFileHandler.ReadLine();
                // Configuration tab: RTS Reset parameters
                textRTSTrue.Text = openedFileHandler.ReadLine();
                textRTSFalse.Text = openedFileHandler.ReadLine();
                // Debug tab : Messages parameters
                checkShowAnswer.Checked = bool.Parse(openedFileHandler.ReadLine());
                checkShowFile.Checked = bool.Parse(openedFileHandler.ReadLine());
                checkShowCheckFile.Checked = bool.Parse(openedFileHandler.ReadLine());
                checkShowAutoDetect.Checked = bool.Parse(openedFileHandler.ReadLine());
                checkShowTransfert.Checked = bool.Parse(openedFileHandler.ReadLine());
                // Configuration tab: "piccodes.ini" file
                textPiccodesPath.Text = openedFileHandler.ReadLine();
                checkForcePiccodes.Checked = bool.Parse(openedFileHandler.ReadLine());
                // Configuration tab: RS232 powering
                checkPowerRTS.Checked = bool.Parse(openedFileHandler.ReadLine());
                // Debug tab : virtual device
                textVirtualPIC.Text = openedFileHandler.ReadLine();
                textVirtualPICFam.Text = openedFileHandler.ReadLine();
                checkVirtualPIC.Checked = bool.Parse(openedFileHandler.ReadLine());
                // last opened files
                string line = openedFileHandler.ReadLine();
                if (line != null)
                    while ((line != "STOP"))
                    {
                        listHexFiles.Items.Add(line);
                        listHexFiles.SelectedIndex = 0; // select last opened file
                        line = openedFileHandler.ReadLine();
                        if (line == null)
                            break;
                    }
                // --- v0.8.1 ---
                if (line != null)
                {
                    // EEPROM erase
                    checkEraseEEPROM.Checked = bool.Parse(openedFileHandler.ReadLine());
                    // get baudrates
                    comboBaudSelect.Items.Clear();
                    while ((line = openedFileHandler.ReadLine()) != "STOP")
                        comboBaudSelect.Items.Add(line);
                    // Configuration tab: get "Special Baud Rates" group values
                    checkUseSpecialBaudRate.Checked = bool.Parse(openedFileHandler.ReadLine());
                    textClockInit.Text = openedFileHandler.ReadLine();
                    textBaudInit.Text = openedFileHandler.ReadLine();
                    textClockFinal.Text = openedFileHandler.ReadLine();
                }
                // --- v0.9.1 ---
                line = openedFileHandler.ReadLine(); // STOP
                if (line != null)
                {
                    // Configuration tab: Reset option: DTR
                    radioResetDTR.Checked = bool.Parse(openedFileHandler.ReadLine());
                    // Configuration tab: Reset option: Remote Signal
                    radioResetRemoteSignal.Checked = bool.Parse(openedFileHandler.ReadLine());
                    textRemoteMessage.Text = openedFileHandler.ReadLine();
                    textRemoteWait.Text = openedFileHandler.ReadLine();
                    // Show help messages
                    checkShowToolTip.Checked = bool.Parse(openedFileHandler.ReadLine());
                }
                // --- v0.11.0 ---
                line = openedFileHandler.ReadLine(); // STOP
                if (line != null)
                {
                    isAtLeastV0_11_0_ConfigFile = true;
                    // Firmwares tab: "Firmwares" folder's path and seek if "firmwares.ini" presence
                    textBoxFirmwareFolder.Text = openedFileHandler.ReadLine();
                    if (textBoxFirmwareFolder.Text != "Wrong folder OR \"firmwares.ini\" missing")
                        verifyFirmwaresIniPresence(textBoxFirmwareFolder.Text);
                    // Firmwares tab: get last selected Brand
                    selectedFirmwareBrandIndex = int.Parse(openedFileHandler.ReadLine());
                    // Firmwares tab: get last selected Device
                    selectedFirmwareDeviceIndex = int.Parse(openedFileHandler.ReadLine());
                    // Firmwares tab: get last selected Flavour
                    selectedFirmwareFlavourIndex = int.Parse(openedFileHandler.ReadLine());
                    // Firmwares tab: "ipecmd.exe" Microchip's file location
                    textBoxIPEfolderPath.Text = openedFileHandler.ReadLine();
                    // Firmwares tab: get last selected PIC Programmer
                    comboPicProgrammer.SelectedIndex = int.Parse(openedFileHandler.ReadLine());
                    // Firmwares tab: must apply VDD through the programmer
                    checkProgrammerVDD.Checked = bool.Parse(openedFileHandler.ReadLine());
                }
                // --- next version ---
                // ### not for the moment

                // select the right baudrate
                comboBaudSelect.SelectedIndex = baudrate_index;
                // when all is done, close config file
                openedFileHandler.Close();
            }

            // terminate configuration
            buttonAutoDetect.Enabled = radioResetRTS.Checked;
            radioResetRTS.Enabled = !checkPowerRTS.Checked;
            radioResetDTR.Enabled = !checkPowerRTS.Checked;
            groupBoxRTSreset.Enabled = (radioResetRTS.Checked||radioResetDTR.Checked) && !checkPowerRTS.Checked;
            groupBoxRemoteSignal.Enabled = radioResetRemoteSignal.Checked;
            calculateSpecialBaudRate();
            textBaudFinal.Enabled = checkUseSpecialBaudRate.Checked;
            textBaudInit.Enabled = checkUseSpecialBaudRate.Checked;
            textClockFinal.Enabled = checkUseSpecialBaudRate.Checked;
            textClockInit.Enabled = checkUseSpecialBaudRate.Checked;
            label31.Enabled = checkUseSpecialBaudRate.Checked;
            label32.Enabled = checkUseSpecialBaudRate.Checked;
            label33.Enabled = checkUseSpecialBaudRate.Checked;
            label34.Enabled = checkUseSpecialBaudRate.Checked;

            if ((radioResetRTS.Checked == false) && (radioResetRemoteSignal.Checked == false) && (radioResetDTR.Checked == false)) 
                radioResetManual. Checked = true;

            if (checkForcePiccodes.Checked) // if checked force to use the choosen file
                piccodesIniFile = textPiccodesPath.Text;
            else // else use the one of the application directory
                piccodesIniFile = Application.StartupPath + "/piccodes.ini";

            // Populate Brand, Device and Flavour comboBox in "Firmwares" tab, then show the last selected item
            if (!isAtLeastV0_11_0_ConfigFile) // not a "config.ini" v.0.11.0 (or higher) file
            {
                // seek "firmwares" folder in "Tiny Bootloader" install folder
                if (verifyFirmwaresIniPresence(Application.StartupPath + "/firmwares"))
                {
                    selectedFirmwareBrandIndex = 0;
                    selectedFirmwareDeviceIndex = 0;
                    selectedFirmwareFlavourIndex = 0;
                }
                comboPicProgrammer.SelectedIndex = 0;
            }
            if (textBoxFirmwareFolder.Text != "Wrong folder OR \"firmwares.ini\" missing")
            {
                readFirmwareIni();
                comboFirmwareBrand.SelectedIndex = selectedFirmwareBrandIndex;
                comboFirmwareDevice.SelectedIndex = selectedFirmwareDeviceIndex;
                comboFirmwareFlavour.SelectedIndex = selectedFirmwareFlavourIndex;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: Form1_Closing
        // Parameters: windows stuff
        // Return: none
        // Description: when the program close it save all configs in "config.ini" file
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void Form1_Closing(object sender, FormClosingEventArgs e)
        {
            StreamWriter saveFileHandler;

            try // if "config.ini" can be writable
            {
                saveFileHandler = File.CreateText(configIniFile);

                // COM config
                saveFileHandler.WriteLine(comboBaudSelect.SelectedIndex.ToString());
                saveFileHandler.WriteLine(selectedCOM.Text);
                // use of RTS
                saveFileHandler.WriteLine(radioResetRTS.Checked.ToString());
                // check file before program PIC
                saveFileHandler.WriteLine(checkFile.Checked.ToString());
                // flash prog write
                saveFileHandler.WriteLine(checkWriteFlashProg.Checked.ToString());
                // EEPROM write
                saveFileHandler.WriteLine(checkWriteEEPROM.Checked.ToString());
                // Debug tab : COM parameters
                saveFileHandler.WriteLine(textReadTimeOut.Text);
                saveFileHandler.WriteLine(textDelayCheck.Text);
                saveFileHandler.WriteLine(textNbChecks.Text);
                // Debug tab : RTS Reset parameters
                saveFileHandler.WriteLine(textRTSTrue.Text);
                saveFileHandler.WriteLine(textRTSFalse.Text);
                // Debug tab : Messages parameters
                saveFileHandler.WriteLine(checkShowAnswer.Checked.ToString());
                saveFileHandler.WriteLine(checkShowFile.Checked.ToString());
                saveFileHandler.WriteLine(checkShowCheckFile.Checked.ToString());
                saveFileHandler.WriteLine(checkShowAutoDetect.Checked.ToString());
                saveFileHandler.WriteLine(checkShowTransfert.Checked.ToString());
                // Debug tab : "piccodes.ini" file
                saveFileHandler.WriteLine(textPiccodesPath.Text);
                saveFileHandler.WriteLine(checkForcePiccodes.Checked.ToString());
                // Debug tab : RS232 powering
                saveFileHandler.WriteLine(checkPowerRTS.Checked.ToString());
                // Debug tab : virtual device
                saveFileHandler.WriteLine(textVirtualPIC.Text);
                saveFileHandler.WriteLine(textVirtualPICFam.Text);
                saveFileHandler.WriteLine(checkVirtualPIC.Checked.ToString());
                // last opened files
                foreach (var path in listHexFiles.Items)
                    saveFileHandler.WriteLine(path.ToString());
                // --- v0.8.1 ---
                saveFileHandler.WriteLine("STOP");
                // EEPROM erase
                saveFileHandler.WriteLine(checkEraseEEPROM.Checked.ToString());
                // save baudrates
                foreach (var baud in comboBaudSelect.Items)
                    saveFileHandler.WriteLine(baud.ToString());
                saveFileHandler.WriteLine("STOP");
                // save "Special Baud Rates" group values
                saveFileHandler.WriteLine(checkUseSpecialBaudRate.Checked.ToString());
                saveFileHandler.WriteLine(textClockInit.Text);
                saveFileHandler.WriteLine(textBaudInit.Text);
                saveFileHandler.WriteLine(textClockFinal.Text);
                // --- v0.9.1 ---
                saveFileHandler.WriteLine("STOP");
                // Reset option: DTR
                saveFileHandler.WriteLine(radioResetDTR.Checked.ToString());
                // Reset option: Remote Signal
                saveFileHandler.WriteLine(radioResetRemoteSignal.Checked.ToString());
                saveFileHandler.WriteLine(textRemoteMessage.Text);
                saveFileHandler.WriteLine(textRemoteWait.Text);
                // Show help messages
                saveFileHandler.WriteLine(checkShowToolTip.Checked.ToString());
                // --- v0.11.0 ---
                saveFileHandler.WriteLine("STOP");
                // Firmwares tab: "Firmwares" folder's path and seek if "firmwares.ini" presence
                saveFileHandler.WriteLine(textBoxFirmwareFolder.Text);
                // Firmwares tab: get last selected Brand
                saveFileHandler.WriteLine(comboFirmwareBrand.SelectedIndex.ToString());
                // Firmwares tab: get last selected Device
                saveFileHandler.WriteLine(comboFirmwareDevice.SelectedIndex.ToString());
                // Firmwares tab: get last selected Flavour
                saveFileHandler.WriteLine(comboFirmwareFlavour.SelectedIndex.ToString());
                // Firmwares tab: "ipecmd.exe" Microchip's file location
                saveFileHandler.WriteLine(textBoxIPEfolderPath.Text);
                // Firmwares tab: get last selected PIC Programmer
                saveFileHandler.WriteLine(comboPicProgrammer.SelectedIndex.ToString());
                // Firmwares tab: must apply VDD through the programmer
                saveFileHandler.WriteLine(checkProgrammerVDD.Checked.ToString());

                // when all is done, close config file
                saveFileHandler.Close();
            }
            catch // if "config.ini" isn't writable
            {
                DialogResult result = MessageBox.Show("Can't write \"config.ini\" file, all configuration changes will be lost. \r\n\r\nEither it's a readonly file or it's placed in a readonly folder.\r\n\r\nChange its read/write attributes or install \"Tiny Avr-Pic Bootloader+\" in a folder writable by the user.",
                    "WARNING:",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Exclamation,
                    MessageBoxDefaultButton.Button1);
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: radioRTS_CheckedChanged
        // Parameters: windows stuff
        // Return: none
        // Description: enable "Auto Conf COM" only in RTS or DTRreset mode
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void radioRTS_CheckedChanged(object sender, EventArgs e)
        {
            buttonAutoDetect.Enabled = radioResetRTS.Checked || radioResetDTR.Checked;
            groupBoxRTSreset.Enabled = radioResetRTS.Checked || radioResetDTR.Checked;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: radioDTR_CheckedChanged
        // Parameters: windows stuff
        // Return: none
        // Description: enable "Auto Conf COM" only in DTR or RTS reset mode
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void radioResetDTR_CheckedChanged(object sender, EventArgs e)
        {
            buttonAutoDetect.Enabled = radioResetRTS.Checked || radioResetDTR.Checked;
            groupBoxRTSreset.Enabled = radioResetRTS.Checked || radioResetDTR.Checked;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: buttonAutoDetect_Click
        // Parameters: windows stuff
        // Return: none
        // Description: auto detect com port and baud rate of a connected PIC with BootLoader firmware
        //              (only if "RTS reset" is enabled and correctly connected to PIC)
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void buttonAutoDetect_Click(object sender, EventArgs e)
        {
            Thread tt = new Thread(new ThreadStart(autoDetect));
            aborted = false;
            tt.Start();
            if (aborted)
            {
                textMessages.AppendText("Detection aborted\r\n");
                textMessages.AppendText("\r\n---------------------------------------------------------\r\n\r\n");
                progressBar.Value = 0;
            }
        }
        private void autoDetect()
        {
            bool autoDetectOK = false;
            int comIndex;
            int baudIndex;
            int barStep;

            // update COM list
            searchCOM();
            // if there is no COM port attached to the PC the exit
            if (listDetectedCOM.Items.Count == 0)
            {
                textMessages.AppendText("Error: There is no COM port attached to the PC!!!\r\n");
                textMessages.AppendText("\r\n---------------------------------------------------------\r\n\r\n");
                return;
            }

            barStep = progressBar.Maximum / (listDetectedCOM.Items.Count * comboBaudSelect.Items.Count);

            // then check if there is a PIC with TinyBootloader connected to a COM:
            textMessages.AppendText("Detecting COM Number and Baud Rate associated to Device...\r\n");

            // at first, test latest used configuration as it's the most probable
            autoDetectOK = autoDetectResult();

            // check all COM...
            for (comIndex = 0; comIndex < listDetectedCOM.Items.Count; comIndex++)
            {
                // go out from "for COM" if a PIC is detected
                if (autoDetectOK)
                    break;

                // select the COM to be tested
                listDetectedCOM.SelectedIndex = comIndex;
                // ...to all baud rates available
                for (baudIndex = 0; baudIndex < comboBaudSelect.Items.Count; baudIndex++)
                {
                    if (aborted)
                        break;

                    // go out from "for baud Rate"
                    if (autoDetectOK)
                        break;

                    progressBar.Value = (comIndex * comboBaudSelect.Items.Count + baudIndex + 1) * barStep;

                    // select a baud rate
                    comboBaudSelect.SelectedIndex = baudIndex;

                    autoDetectOK = autoDetectResult();
                }
            }

            if (autoDetectOK)
                textMessages.AppendText("Auto Conf COM OK with: " + selectedCOM.Text + ", " + int.Parse((string)comboBaudSelect.SelectedItem) + " bauds\r\n");
            else
                textMessages.AppendText("Error: Can't detect a Device with TinyBootLoader !!!\r\n");

            textMessages.AppendText("\r\n---------------------------------------------------------\r\n\r\n");

            progressBar.Value = 0;
        }
        private bool autoDetectResult()
        {
            openSerial(false);

            if (serialPort.IsOpen)
            {
                if (checkShowAutoDetect.Enabled)
                    textMessages.AppendText("   Trying " + selectedCOM.Text + ", " + int.Parse((string)comboBaudSelect.SelectedItem) + " bauds...");

                // verify if a PIC answer to a "checkPIC"
                if (checkPIC(1, false))
                {
                    if (checkShowAutoDetect.Enabled)
                        textMessages.AppendText("   Device detected :-)\r\n");
                    closeSerial(false);
                    return true;
                }
                else
                {
                    if (checkShowAutoDetect.Enabled)
                        textMessages.AppendText("   Device not detected :-(\r\n");
                    closeSerial(false);
                    return false;
                }
            }
            else
                return false;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: serialPort_DataReceived
        // Parameters: window's stuff
        // Return: none
        // Description: just for development debug purpose (don't care)
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void serialPort_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            //textMessages.AppendText("something received\r\n");
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: checkForcePiccodes_CheckedChanged
        // Parameters: window's stuff
        // Return: none
        // Description: enable or disable the choice/use of a special "piccodes.ini" files
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void checkForcePiccodes_CheckedChanged(object sender, EventArgs e)
        {
            textPiccodesPath.Enabled = checkForcePiccodes.Checked;
            doChoosePiccodes.Enabled = checkForcePiccodes.Checked;

            if (checkForcePiccodes.Checked) // if checked force to use the choosen file
                piccodesIniFile = textPiccodesPath.Text;
            else // else use the one of the application directory
                piccodesIniFile = Application.StartupPath + "/piccodes.ini";
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: doChoosePiccodes_Click
        // Parameters: window's stuff
        // Return: none
        // Description: if "browse" button is clicked, open a file select dialog with "*.ini" pre-selection 
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void doChoosePiccodes_Click(object sender, EventArgs e)
        {
            openPiccodesFile.InitialDirectory = Application.StartupPath;
            openPiccodesFile.ShowDialog();
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: openPiccodesFile_FileOk
        // Parameters: windows stuff
        // Return: none
        // Description: if a "ini" file is correctly selected, then show in to "textPiccodesPath" text zone
        //              and select it as the new "piccodes.ini" to use
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void openPiccodesFile_FileOk(object sender, CancelEventArgs e)
        {
            piccodesIniFile = openPiccodesFile.FileName;
            textPiccodesPath.Text = piccodesIniFile;
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: doChooseFirmwaresFolder_Click
        // Parameters: windows stuff
        // Return: none
        // Description: permits to the user to select where is the "firmwares" folder
        //              AND verification if "firmwares.ini" file is effectively in this folder
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void doChooseFirmwaresFolder_Click(object sender, EventArgs e)
        {
            string selectedFolder = "";

            fb_Firmwares.SelectedPath = "";
            fb_Firmwares.ShowDialog();
            selectedFolder = fb_Firmwares.SelectedPath;
            if (selectedFolder != "")
            {
                //verify if "firmwares.ini" is in this folder
                if (verifyFirmwaresIniPresence(selectedFolder))
                {
                    // if so, then get the data and display the first one
                    readFirmwareIni();
                    comboFirmwareBrand.SelectedIndex = 0;
                }
            }
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: verifyFirmwaresIniPresence
        // Parameters: folder where "firmwares.ini" could be
        // Return: none
        // Description: verification if "firmwares.ini" file is effectively in this folder
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private bool verifyFirmwaresIniPresence(string folder)
        {
            bool isFirmwaresIniThere = false;

            DirectoryInfo di_selectedFolder = new DirectoryInfo(folder);
            FileInfo[] fi_filesList;

            if (di_selectedFolder.Exists)
            {
                fi_filesList = di_selectedFolder.GetFiles();
                foreach (FileInfo file in fi_filesList)
                {
                    if (file.Name.ToLower() == "firmwares.ini")
                        isFirmwaresIniThere = true;
                }
                if (isFirmwaresIniThere == true)
                {
                    textBoxFirmwareFolder.Text = folder;
                    return true;
                }
            }
            textBoxFirmwareFolder.Text = "Wrong folder OR \"firmwares.ini\" missing";

            return false;
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: readFirmwareIni
        // Parameters: none
        // Return: none
        // Description: read all data from "firmwares.ini" and then stock then in their appropriate structures
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void readFirmwareIni()
        {
            StreamReader openedFileHandler;
            string line;
            string[] infos;
            infos = new string[firmwaresIniMaxInfoPerline];

            // if "firmwares.ini" file exists open it to grab detected PIC infos
            if (File.Exists(textBoxFirmwareFolder.Text + "/firmwares.ini"))
            {
                openedFileHandler = File.OpenText(textBoxFirmwareFolder.Text + "/firmwares.ini");
                comboFirmwareBrand.Items.Clear();
                while ((line = openedFileHandler.ReadLine()) != null)
                {
                    string[] stringSeparators = new string[] { ",", ":" };

                    line = line.Trim(); // clear space before and after the text
                    if (line.Length > 0) // if it remains something
                    {
                        if (!line.StartsWith(";")) // line starting with ";" is a remark
                        {
                            infos = line.Split(stringSeparators, StringSplitOptions.RemoveEmptyEntries);
                            infos[0] = infos[0].Trim();

                            switch (infos[0])
                            {
                                case "B":
                                    // add the new brand to the list
                                    allFirmwaresInfos.Add(new Brand() { name = infos[1].Trim(), devices = new List<Device>() });
                                    // and add it too to the Brand's ComboBox
                                    comboFirmwareBrand.Items.Add(infos[1].Trim());
                                    break;
                                case "D":
                                    allFirmwaresInfos.Last().devices.Add(new Device() { name = infos[1].Trim(), flavours = new List<Flavour>() });
                                    break;
                                case "F":
                                    allFirmwaresInfos.Last().devices.Last().flavours.Add(new Flavour()
                                    {
                                        name = infos[1].Trim(),
                                        clock_type = infos[2].Trim(),
                                        frequency = infos[3].Trim(),
                                        baudrate = infos[4].Trim(),
                                        RX_pin = infos[5].Trim(),
                                        TX_pin = infos[6].Trim(),
                                        firmware_hex_file_name = infos[7].Trim()
                                    });
                                    break;
                            }
                        }
                    }
                }
                openedFileHandler.Close();
            }
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: comboFirmwareBrand_SelectedIndexChanged, 
        //       comboFirmwareDevice_SelectedIndexChanged,
        //       comboFirmwareFlavour_SelectedIndexChanged
        // Parameters: windows stuff
        // Return: none
        // Description: change informations in "Firmware" tab accordingly to Brand, Device and Flavour choosed
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void comboFirmwareBrand_SelectedIndexChanged(object sender, EventArgs e)
        {
            comboFirmwareDevice.Items.Clear();
            // populate device's combobox
            Brand tempbrand = allFirmwaresInfos.Find(x => x.name == comboFirmwareBrand.Text);
            foreach (Device tempdevice in tempbrand.devices)
                comboFirmwareDevice.Items.Add(tempdevice.name);
            comboFirmwareDevice.SelectedIndex = 0;
        }
        private void comboFirmwareDevice_SelectedIndexChanged(object sender, EventArgs e)
        {
            comboFirmwareFlavour.Items.Clear();
            // populate flavour's combobox
            Brand tempbrand = allFirmwaresInfos.Find(x => x.name == comboFirmwareBrand.Text);
            Device tempdevice = tempbrand.devices.Find(x => x.name == comboFirmwareDevice.Text);
            foreach (Flavour tempflavour in tempdevice.flavours)
                comboFirmwareFlavour.Items.Add(tempflavour.name);
            comboFirmwareFlavour.SelectedIndex = 0;
        }
        private void comboFirmwareFlavour_SelectedIndexChanged(object sender, EventArgs e)
        {
            // populate firmwares' tab text boxes
            Brand tempbrand = allFirmwaresInfos.Find(x => x.name == comboFirmwareBrand.Text);
            Device tempdevice = tempbrand.devices.Find(x => x.name == comboFirmwareDevice.Text);
            Flavour tempflavour = tempdevice.flavours.Find(x => x.name == comboFirmwareFlavour.Text);
            textClockType.Text = tempflavour.clock_type;
            textFreq.Text = tempflavour.frequency;
            textDefaultBaudRate.Text = tempflavour.baudrate;
            textDefaultRXpin.Text = tempflavour.RX_pin;
            textDefaultTXpin.Text = tempflavour.TX_pin;
            textFirmwareFileName.Text = tempflavour.firmware_hex_file_name;
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: doChooseIPEfolder_Click
        // Parameters: windows stuff
        // Return: none
        // Description: permits to the user to select where is the Microchip's "ipecmd.exe" file
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void doChooseIPEfolder_Click(object sender, EventArgs e)
        {
            openIPEcmdFile.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86);
            openIPEcmdFile.ShowDialog();
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: openPiccodesFile_FileOk
        // Parameters: windows stuff
        // Return: none
        // Description: if a "ini" file is correctly selected, then show in to "textPiccodesPath" text zone
        //              and select it as the new "piccodes.ini" to use
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void openIPEcmdFile_FileOk(object sender, CancelEventArgs e)
        {
            ipeCmdFile = openIPEcmdFile.FileName;
            textBoxIPEfolderPath.Text = ipeCmdFile;
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: openPiccodesFile_FileOk
        // Parameters: windows stuff
        // Return: none
        // Description: if a "ini" file is correctly selected, then show in to "textPiccodesPath" text zone
        //              and select it as the new "piccodes.ini" to use
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void b_flashDevice_Click(object sender, EventArgs e)
        {
            string[] programmers = { "PK3", "ICD3", "RICE", "PM3", "PKOB" };
            string ext_alim = "";

            if (checkProgrammerVDD.Checked)
                ext_alim = " -W";

            var proc = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = textBoxIPEfolderPath.Text,
                    Arguments = "-TP" + programmers[comboPicProgrammer.SelectedIndex] + ext_alim + " -P" + comboFirmwareDevice.Text + " -M -F\"" + textBoxFirmwareFolder.Text + textFirmwareFileName.Text + "\"",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    CreateNoWindow = true
                }
            };

            tb_Test.AppendText("\r\nProgramming started. Wait...\r\n");
            try
            {
                proc.Start();
                while (!proc.StandardOutput.EndOfStream)
                    tb_Test.AppendText(proc.StandardOutput.ReadLine() + "\r\n");
            }
            catch (System.ComponentModel.Win32Exception f) // error: can't launch the specified ".exe" file
            {
                tb_Test.AppendText("\r\nerror: can't launch the specified \".exe\" file\r\n");
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: Form1_Shown
        // Parameters: windows stuff
        // Return: none
        // Description: Command line options are handled in this function.
        //              The first time the form is shown, write the file passed as argument to the PIC
        //              syntax:
        //              file.hex [auto|COMx [baurate]] [exit]
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void Form1_Shown(object sender, EventArgs e)
        {
            Thread tt = new Thread(new ThreadStart(analyseCommandLine));
            aborted = false;
            tt.Start();
        }
        private void analyseCommandLine()
        {
            // check if there is a command line parameter -> write it to PIC
            String[] arguments = Environment.GetCommandLineArgs();

            if (arguments.Length > 1) // more than one argument, then they are options passed in the command line
            {
                this.BringToFront();
                this.TopMost = true;
                this.Show();

                this.Update(); // display instantly the form

                // argument 1 (=file name)
                if (arguments[1].ToLower().Contains(".hex"))
                {
                    if (listHexFiles.Items.Contains(arguments[1]))
                    {
                        // file already in list, so remove it before put it at the first place...
                        // ... it's easier than just move it to the right place
                        listHexFiles.Items.Remove(arguments[1]);
                    }
                    listHexFiles.Items.Insert(0, arguments[1]); // add file name at the top of the list...
                    listHexFiles.SelectedIndex = 0; // and display it in text zone
                }
                else
                {
                    textMessages.AppendText("ERROR: no \".hex\" file passed as argument!\r\n");
                    textMessages.AppendText("\r\n---------------------------------------------------------\r\n\r\n");
                    return;
                }

                // argument 2 (COM port or AUTO or EXIT)
                if (arguments.Length > 2)
                {
                    if (arguments[2].ToUpper().Contains("COM"))
                        selectedCOM.Text = arguments[2].ToUpper();
                    else if (arguments[2].ToUpper().Contains("AUTO"))
                    {
                        if (checkVirtualPIC.Checked == false) // can't work in simulation mode
                            autoDetect();
                    }
                    else if (arguments[2].ToUpper().Contains("EXIT"))
                        exitSuccessfulWrite = true;
                    else
                    {
                        textMessages.AppendText("ERROR: wrong syntax for second argument! Must be COMx or AUTO or EXIT\r\n");
                        textMessages.AppendText("\r\n---------------------------------------------------------\r\n\r\n");
                        return;
                    }
                }

                // argument 3 (baudrate or EXIT)
                if (arguments.Length > 3)
                {
                    if (arguments[3].ToUpper().Contains("EXIT"))
                        exitSuccessfulWrite = true;
                    else
                    {
                        try
                        {
                            if (int.Parse(arguments[3]) != 0)
                            {
                                int baudrate = int.Parse(arguments[3]);
                                int selectedindex = -1;
                                int index = 0;

                                // seek the baudrate given in arguments in the "Baud Rate" list box
                                foreach (var baud in comboBaudSelect.Items)
                                {
                                    if (int.Parse(baud.ToString()) == baudrate)
                                        selectedindex = index;
                                    index++;
                                }

                                if (selectedindex != -1)
                                    comboBaudSelect.SelectedIndex = selectedindex;
                                else
                                {
                                    textMessages.AppendText("ERROR: BaudRate argument must already be in the \"Baud Rate\" list box\r\n");
                                    textMessages.AppendText("\r\n---------------------------------------------------------\r\n\r\n");
                                    return;
                                }
                            }
                        }
                        catch
                        {
                            textMessages.AppendText("ERROR: wrong syntax for BaudRate argument! Must be 115200, 57600, 38400, 19200 or 9600\r\n");
                            textMessages.AppendText("\r\n---------------------------------------------------------\r\n\r\n");
                            return;
                        }
                    }
                }
                // argument 4 (EXIT)
                if (arguments.Length > 4)
                {
                    if (arguments[4].ToUpper().Contains("EXIT"))
                        exitSuccessfulWrite = true;
                }

                this.Update(); // display instantly the form again, to display the right COM & Baudrate (if changed from previous session)
                writeFile();
                if ((writeSuccess == 1) && (exitSuccessfulWrite == true))
                        Application.Exit();
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: Form1_DragEnter
        // Parameters: windows stuff
        // Return: none
        // Description: do a descrimination when an object is put on the windows form (only files)
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void Form1_DragEnter(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                e.Effect = DragDropEffects.All;
            }
            else
            {
                e.Effect = DragDropEffects.None;
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Name: Form1_DragDrop
        // Parameters: windows stuff
        // Return: none
        // Description: if the object put on the windows form is an ".hex" or ".eep" file then:
        //              - then add it to "listHexFiles" list view and select it for a future use 
        //              - write it to the device
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        private void Form1_DragDrop(object sender, DragEventArgs e)
        {
            string[] s = (string[])e.Data.GetData(DataFormats.FileDrop, false);
            int i;
            int nbHexFiles = 0;
            string fileToWrite = "";

            // verify files droped on the form
            for (i = 0; i < s.Length; i++)
            {
                if ((s[i].ToUpper().EndsWith(".HEX")) || (s[i].ToUpper().EndsWith(".EEP")))
                {
                    nbHexFiles++;
                    if (nbHexFiles == 1)
                        fileToWrite = s[i];
                }
            }

            // if at least one ".HEX" or ".EEP" file is droped
            if (nbHexFiles > 0)
            {
                if (nbHexFiles > 1)
                {
                    textMessages.AppendText("WARNING: Multiple \".HEX|.EEP\" files Drag&Drop. Will only\r\n");
                    textMessages.AppendText("         use the first file!\r\n");
                }

                // add it to "listHexFiles" list view and select it for a future use...
                if (listHexFiles.Items.Contains(fileToWrite))
                {
                    // file already in list, so remove it before put it at the first place...
                    // ... it's easier than just move it to the right place
                    listHexFiles.Items.Remove(fileToWrite);
                }
                listHexFiles.Items.Insert(0, fileToWrite); // add file name at the top of the list...
                listHexFiles.SelectedIndex = 0; // and display it in text zone

                //... then try to write it to the device
                Thread tt = new Thread(new ThreadStart(writeFile));
                aborted = false;
                tt.Start();
            }
            else
                textMessages.AppendText("ERROR: No \".HEX\" files to write!!!\r\n");
        }

        private void linkCChiculita_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            linkCChiculita.LinkVisited = true;
            System.Diagnostics.Process.Start("http://www.etc.ugal.ro/cchiculita/software/picbootloader.htm");
        }

        private void linkSourceForge_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            linkSourceForge.LinkVisited = true;
            System.Diagnostics.Process.Start("http://sourceforge.net/projects/tinypicbootload/");
        }

        private void buttonDonate_Click(object sender, EventArgs e)
        {
            System.Diagnostics.Process.Start("https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=B72HVTER4LZ3Y");
        }

        // all reset methods are disabled because with Power from RTS + DTR the device is allways reseted at powerup!
        private void checkPowerRTS_CheckedChanged(object sender, EventArgs e)
        {
            radioResetRTS.Enabled = !checkPowerRTS.Checked;
            radioResetDTR.Enabled = !checkPowerRTS.Checked;
            radioResetManual.Enabled = !checkPowerRTS.Checked;
            radioResetRemoteSignal.Enabled = !checkPowerRTS.Checked;
            groupBoxRTSreset.Enabled = (radioResetRTS.Enabled && radioResetRTS.Checked) || (radioResetDTR.Enabled && radioResetDTR.Checked);
        }

        private void checkVirtualPIC_CheckedChanged(object sender, EventArgs e)
        {
            textVirtualPIC.Enabled = checkVirtualPIC.Checked;
            textVirtualPICFam.Enabled = checkVirtualPIC.Checked;

            if (checkVirtualPIC.Checked)
                buttonWrite.Text = "Simulate";
            else
                buttonWrite.Text = "Write Device";
        }

        private void buttonAbort_Click(object sender, EventArgs e)
        {
            aborted = true;
        }

        private void linkOnlineSupport_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            System.Diagnostics.Process.Start("http://sourceforge.net/p/tinypicbootload/discussion/");
        }

        private void checkWriteConfig_CheckedChanged(object sender, EventArgs e)
        {
            if (checkWriteConfig.Checked == true)
            {
                DialogResult result = MessageBox.Show("You can destroy the bootloader \r\nby sending a bad configuration!!!\r\n\r\nDo you want to continue?",
                    "WARNING:",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Exclamation,
                    MessageBoxDefaultButton.Button2);

                if (result == DialogResult.No)
                    checkWriteConfig.Checked = false;
            }
        }

        private void checkUseSpecialBaudRate_CheckedChanged(object sender, EventArgs e)
        {
            textBaudFinal.Enabled = checkUseSpecialBaudRate.Checked;
            textBaudInit.Enabled = checkUseSpecialBaudRate.Checked;
            textClockFinal.Enabled = checkUseSpecialBaudRate.Checked;
            textClockInit.Enabled = checkUseSpecialBaudRate.Checked;
            label31.Enabled = checkUseSpecialBaudRate.Checked;
            label32.Enabled = checkUseSpecialBaudRate.Checked;
            label33.Enabled = checkUseSpecialBaudRate.Checked;
            label34.Enabled = checkUseSpecialBaudRate.Checked;
        }

        private void calculateSpecialBaudRate()
        {
            long specialBaudRate = 0;

            specialBaudRate = (Int64.Parse(textClockFinal.Text) * Int64.Parse(textBaudInit.Text));
            specialBaudRate /= Int64.Parse(textClockInit.Text);
            textBaudFinal.Text = specialBaudRate.ToString();
        }

        private void textClockInit_TextChanged(object sender, EventArgs e)
        {
            calculateSpecialBaudRate();
        }

        private void textClockFinal_TextChanged(object sender, EventArgs e)
        {
            calculateSpecialBaudRate();
        }

        private void textBaudInit_TextChanged(object sender, EventArgs e)
        {
            calculateSpecialBaudRate();
        }

        private void linkDoc_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            System.Diagnostics.Process.Start("http://tinypicbootload.sourceforge.net/");
        }

        private void checkShowToolTip_CheckedChanged(object sender, EventArgs e)
        {
            toolTip.Active = checkShowToolTip.Checked;                
        }

        private void radioResetRemoteSignal_CheckedChanged(object sender, EventArgs e)
        {
            groupBoxRemoteSignal.Enabled = radioResetRemoteSignal.Checked;
        }

        private void link8051List_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            System.Diagnostics.Process.Start("http://tinypicbootload.sourceforge.net/tested_devices_8051.html");
        }

        private void linkAtmelList_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            System.Diagnostics.Process.Start("http://tinypicbootload.sourceforge.net/tested_devices_avr.html");
        }

        private void linkMicrochipList_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            System.Diagnostics.Process.Start("http://tinypicbootload.sourceforge.net/tested_devices_pic.html");
        }

        private void linkNxpList_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            System.Diagnostics.Process.Start("http://tinypicbootload.sourceforge.net/tested_devices_nxp.html");
        }

        private void linkTiList_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            System.Diagnostics.Process.Start("http://tinypicbootload.sourceforge.net/tested_devices_ti.html");
        }
    }
}
